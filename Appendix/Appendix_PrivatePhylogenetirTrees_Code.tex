
\appendix

\chapter{Jukes-Cantor distance for CBMC-GC}\label{appendix:appendixA}
%\addcontentsline{toc}{chapter}{Appendix A}

%\begin{appendices}
%
%\section{Jukes-Cantor code for CBMC-GC}
%\label{appendix:JC}


\begin{lstlisting}
#define LEN_SEQ 4000

typedef struct {
	unsigned short el[LEN_SEQ];
} Array_Seq;

const unsigned int m1  = 0x55555555; //binary: 0101...
const unsigned int m2  = 0x33333333; //binary: 00110011..
const unsigned int m4  = 0x0f0f0f0f; //binary:  4 zeros,  4 ones ...
const unsigned int m8  = 0x00ff00ff; //binary:  8 zeros,  8 ones ...

unsigned int popcount(unsigned short INPUT_B_x) {
    unsigned int x = INPUT_B_x;
    x = (x & m1 ) | ((x >>  1) & m1 ); 
    x = (x & m2 ) + ((x >>  2) & m2 );
    x = (x & m4 ) + ((x >>  4) & m4 ); 
    x = (x & m8 ) + ((x >>  8) & m8 );
    return x;
}

void mpc_main(Array_Seq INPUT_A, Array_Seq INPUT_B){
	unsigned int distance = 0;
	int total = 0;
	for(int i=0; i<LEN_SEQ; i++){		
		int count_a = popcount(INPUT_A.el[i]);
		int count_b = popcount(INPUT_B.el[i]);
		if(count_a > 0 && count_b > 0){
			int c_axorb = popcount(INPUT_A.el[i]^INPUT_B.el[i]);			
			if(c_axorb == 1){
				distance = distance + 1;
			}
			total = total + 8;
		}
	}
	unsigned int OUTPUT_distance;
	if(distance > 0){
		OUTPUT_distance = total/distance;
	} else {
		OUTPUT_distance = 0;
	}
}
\end{lstlisting}
 
%\end{appendices}

%
%
%
%\bibliography{bibforthesis}
%\bibliographystyle{unsrt}
%
%\end{document}