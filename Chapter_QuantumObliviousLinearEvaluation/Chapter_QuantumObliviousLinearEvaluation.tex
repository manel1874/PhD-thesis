%\documentclass[11pt]{report}



%\begin{document}

\chapter{Quantum oblivious linear evaluation}
\label{ch:QOLE}

{\cv The topic of this Chapter are the results of [AM16], that have been obtained in collaboration with Gorjan Alagic, and large parts of this article are used here unaltered.}

{\cv This introduction has already been used in the introduction of the thesis.}

Oblivious Linear Evaluation (OLE) is a cryptographic task that permits two distrustful parties, say Alice and Bob, to jointly compute the output of a linear function $f(x)=ax+b$ in some finite field, $\mathbb{F}$. Alice provides inputs $a, b\in\mathbb{F}$ and Bob provides $x\in\mathbb{F}$, while the output, $f(x)$, becomes available only to Bob. As the parties are distrustful, a secure OLE protocol should not permit Alice to learn anything about Bob's input, while also Alice's inputs should remain unknown to Bob.  OLE can be seen as a generalization of Oblivious Transfer (OT) \cite{Rabin81}, a basic primitive for secure two-party computation, which is a special case of secure multi-party computation \cite{Goldreichbook04,CCD88,Canetti00MPC}. OT has been shown to be complete  for secure multi-party computation \cite{Kilian}, i.e., any such task, including OLE, can be achieved given an OT implementation. 
A compelling reason to study OLE protocols is that they can serve as building blocks for the secure evaluation of arithmetic circuits \cite{AIK11,DKMQ12,GNN17,DGNBNT17}, just like OT allows the secure evaluation of boolean circuits \cite{GMW87}. Specifically, OLE can be used to generate multiplication triples which are the basic tool for securely computing multiplication gates \cite{DGNBNT17}. Besides that, OLE has applications in more tasks for two-party secure computation  \cite{IPS09,ADINZ17,BCGI18,HIMV19,CDIKLOV19} and private set intersection \cite{GN19}.
 
Impagliazzo and Rudich proved that OT protocols require public-key cryptography and cannot just rely on symmetric cryptography \cite{IR89}. Consequently, OLE cannot rely on symmetric cryptography either, and we need to resort to public-key cryptography.  However, Shor's  quantum algorithm \cite{Shor94}  poses a threat to the currently deployed public-key systems, motivating the search for protocols secure against quantum attacks. Bennet et al. \cite{BBCS92} and Cr{\'e}peau \cite{C94} proposed the first protocols for quantum OT (QOT). As far as quantum OLE (QOLE) is concerned, to the best of our knowledge, no protocol has been proposed as of now.
Analogously to the classical case it is expected that one can implement QOLE based on QOT protocols. That said, in this work we propose a protocol for QOLE that, additionally, does not rely on any QOT implementation.

OLE is commonly generalized to vector OLE (VOLE). In this setting, Alice defines a set of $k$ linear functions $(\bm{a}, \bm{b})\in\mathbb{F}^k\times\mathbb{F}^k$ and Bob receives the evaluation of all these functions on a specified element $x\in\mathbb{F}$, i.e. $\bm{f}:=\bm{a} x+ \bm{b}$. One can think of VOLE as the arithmetic analog of string OT and show how it can be used  in certain Secure Arithmetic Computation and Non-Interactive Zero Knowledge proofs \cite{BCGI18}. Ghosh et. al  put further in evidence the usefulness of VOLE by showing that it serves as the building block of Oblivious Polynomial Evaluation \cite{GNN17}, a primitive which allows more sophisticated applications, such as password authentication, secure  list intersection,  anonymous complaint boxes \cite{NP06}, anonymous initialization for secure metering of client visits in servers \cite{NP99},  secure Taylor approximation of relevant functions (e.g. logarithm) \cite{LP02}, secure set intersection \cite{H18} and distributed generation of RSA keys \cite{G99}.  We also show how our QOLE protocol can be adapted to achieve secure VOLE.

\section{Contributions overview}\label{Intro_contributions}

 We present a quantum protocol for OLE with universally composable security (quantum-UC security, see Definition \ref{def:statisticalquc}) in the $\mathcal{F}_{\textbf{COM}}-$hybrid model, i.e. when assuming the existence of a commitment functionality, $\mathcal{F}_{\textbf{COM}}$ (see Figure \ref{fig:func_com}). To obtain a secure protocol, we take advantage of the properties of Mutually Unbiased Bases (MUBs) in high-dimensional Hilbert spaces with prime and prime-power dimension. Such a choice is motivated by recent theoretical and experimental advances that pave the way for the development and realization of new solutions for quantum cryptography \cite{BPT00, CBKG02, AGS03, AKBH07, SS10, DEBZ10, Zhongetal2015, Sitetal17, Bouchardetal18, BHVBFHM18, DHMPPV21}. To the best of our knowledge, our protocol is the first proposal of a QOLE protocol which we prove to be quantum-UC secure. Moreover, it is not based on any QOT implementation which would be the standard approach. To prove its security, the only assumption we make is the existence of a commitment functionality. We consider the static corruption adversarial model with both semi-honest and dishonest adversaries (see Section \ref{Prelim_QUC}). Finally, we modify the proposed protocol  to  generate quantum-UC secure VOLE.

\

\noindent\textbf{Main tool.} The proposed protocol $\pi_{\textbf{QOLE}}$ (see Figure \ref{fig:fullprotocol}) is based on the fact that in a Hilbert space of dimension $d$ (isomorphic to $\mathbb{Z}_d$) there exists a set of MUBs $\{\ket{e^x_r}\}_{x, r\in\mathbb{Z}_d}$, such that, upon the action of a certain operator $V^b_a$,  each basis element $r$ is shifted by some linear factor $ax - b$ inside the same basis $x$:

\begin{equation}
    V^b_a \ket{e^x_r} = c_{a,b,x, r} \ket{e^x_{ax - b + r}},
    \label{eq:main_equation_1.3.}
\end{equation}
where $a, b, x, r \in \mathbb{Z}_d =\{0,1,\ldots,d-1\}$. If Alice controls the operator $V^b_a$ and Bob controls the quantum state $\ket{e^x_r}$, they are able to compute a linear function $f(x) = ax - b$ where effectively Alice controls the function $f = (a, b)$ and Bob controls its input $x$. Moreover, since Bob controls $x$ and $r$, he can receive $f(x)$ by measuring the output element. 

\

\noindent\textbf{Protocol overview.} In a nutshell, the QOLE protocol (see Figure \ref{fig:fullprotocol}) with inputs $f = (a,b)$ from Alice and $x$ from Bob is divided into two main phases. In the first \textit{quantum phase}, Alice and Bob use high-dimensional quantum states to generate $n$ random weak OLE (RWOLE) instances, where $n$ is the security parameter.  In this phase, Alice  outputs  $n$ random elements $f^0_i = (a^0_i, b^0_i)$, and Bob  outputs $n$ elements $(x^0_i, y^0 = f^0_i(x^0_i))$. These instances are considered to be weaker because Bob is allowed to have some amount of information about the $n$ outputs of Alice $(a^0_i, b^0_i)$. In the second \textit{post-processing phase}, Alice and Bob use classical tools to extract one secure OLE from the aforementioned $n$ instances.

More specifically, in the quantum phase, Bob randomly generates $m=(1 + t)n$ quantum states $\ket{e^{x^0_i}_{r_i}}$ and sends them to Alice. Then, Bob commits to his choice $(x^0_i, r_i)$, $\forall i\in [m]$, where for any $l\in\mathbb{N}$, $[l]$ denotes the set $\{1, \ldots, l\}$, using an ideal commitment functionality, $\mathcal{F}_{\textbf{COM}}$, and Alice asks to verify  a subset $T$ of size $tn$ of these commitments. This intermediate \textit{commit-and-open} step allows Alice to test Bob's behaviour and ensure that he does not deviate \textit{too much} from the protocol, and it is a common method used in security proofs of QOT protocols \cite{Unruh10, DFLSS09}. If Bob passes all the tests, Alice randomly generates $(a^0_i, b^0_i)$ and applies $V^{b^0_i}_{a^0_i}$ to the remaining $n$ received states $\ket{e^{x^0_i}_{r_i}}$,  for $i\in [m]\setminus T$.  For the rest of this section we relabel and denote $[n]=[m]\setminus T$. According to the expression~\eqref{eq:main_equation_1.3.}, the output states are given by $\ket{e^{x^0_i}_{a^0_i x^0_i - b^0_i + r_i}}$ and she sends them to Bob, who outputs $y^0_i = a^0_i x^0_i - b^0_i$ by measuring the received states in the corresponding basis $ x^0_i$ and subtracting $r_i$,  $\forall i\in [n]$. 


The post-processing phase uses two subprotocols: a derandomization step (see Figure \ref{fig:nOLE}) and an extraction step (see Figure \ref{fig:privacy_amplification}). The derandomization step is based on the protocol $\pi^n_{\text{OLE}}$ from \cite{DHNO19} and transforms the $n$ RWOLE instances into $n$ weak OLE (WOLE) instances with inputs $(a_i, b_i)_{i\in [n]}$ chosen by Alice and inputs $x_i$ for $i\in [n]$ chosen by Bob. The extraction protocol uses the so-called \textit{Multi-linear Modular Hashing} family, $\mathfrak{G}$, of two-universal hash functions \cite{HK97} to render Bob's information on Alice's system useless and to extract one secure OLE out of $n$ instances of WOLE. In the extraction phase, Alice samples a two-universal hash function $g_{\bm{\kappa}}$ from $\mathfrak{G}$ and sends it to Bob. Then, with adequately-crafted vectors $(\bm{a}, \bm{b}) = \big( (a_1, \ldots, a_n), (b_1, \ldots, b_n) \big)$, Alice has $a = g_{\bm{\kappa}}(\bm{a})$ and $b = g_{\bm{\kappa}}(\bm{b})$, and Bob outputs $y = g_{\bm{\kappa}}(\bm{y})$, where $\bm{y} = \bm{a} \bm{x} + \bm{b}$ after point-wise vector multiplication with the constant vector $\bm{x} = (x, \ldots, x)$. 



\


\noindent\textbf{quantum-UC security.} %The intuition behind the security of the proposed protocol $\pi_{\textbf{QOLE}}$ comes from the following observations. 
Due to the quantum nature of the states $\ket{e^{x^0_i}_{r_i}}_{i\in [n]}$, a dishonest Alice is not able to distinguish which bases $x^0_i, i\in [n]$ are used by Bob. From her point of view, Bob's states are maximally mixed and therefore completely hide $x^0_i$. This is enough to ensure that, in the derandomization step, Alice does not receive any information about Bob's final input $x$. For a dishonest Bob, to correctly pass all Alice's tests, it means he did not cheat at all rounds with overwhelming probability. This ensures that he  has some \textit{bounded} information on Alice's random elements $(a^0_i, b^0_i)_{i\in [n]}$, and using privacy amplification techniques in the extraction step, Alice can guarantee that Bob's information about her final input $(a,b)$ is the same as in the case of an ideal OLE functionality, i.e. the probability distribution of $a$ is close to uniform.

Turning this intuition into a quantum-UC security proof requires some additional insights. First, we need a way to quantify Bob's information on Alice's elements $(a^0_i, b^0_i)$ after the testing phase and the application of the corresponding $V^{b^0_i}_{a^0_i}$  operators, for $ i\in [n]$; for this purpose we use the quantum \textit{min-entropy} (see Definition \ref{def:Hmin}). We follow the approach of \cite{DFLSS09} to guarantee that Bob does not significantly deviate from the protocol in all the rounds, and we use Theorem 1 from~\cite{Dupuis2015} to compute a concrete lower bound of Bob's min-entropy on Alice elements $(a^0_i, b^0_i)_{i\in [n]}$. Along with Lemma \ref{lem:leftover}, we have that $a = g_{\bm{\kappa}}(\bm{a})$ is close to uniform, which is sufficient to prove that Bob does not know more about $(a,b)$ than what the output $y = ax + b$ reveals. 

In order to show that the protocol $\pi_{\textbf{QOLE}}$ is quantum-UC secure, we need to show that an ideal execution of $\pi_{\textbf{QOLE}}$ with access to $\mathcal{F}_{\textbf{OLE}}$ (Figure \ref{fig:func_ole}) is indistinguishable from a real execution of the protocol from the point of view of an external entity called the \textit{environment}. To prove this indistinguishability, we have to build a simulator that simulates the execution of the protocol in the ideal setting and generates messages on behalf of the honest simulated parties,  while trying to extract the dishonest party's inputs and feed them in $\mathcal{F}_{\textbf{OLE}}$. In particular, for a dishonest Alice, we have to demonstrate the existence of a simulator, $\mathcal{S}_A$, that generates messages on behalf of honest Bob and extracts Alice's input $(a,b)$ which, in turn, feeds into $\mathcal{F}_{\textbf{OLE}}$.  To this end, we consider that $\mathcal{S}_A$ simulates an attack by Bob at all rounds, $i$, of the protocol  which allows to extract the $m$ values of Alice  $(a^0_i,b^0_i)$. However, the commit-and-open scheme described above is designed to catch such an attack, and to work around this issue we substitute the ideal commitment functionality, $\mathcal{F}_{\textbf{COM}}$, with a fake commitment functionality, $\mathcal{F}_{\textbf{FakeCOM}}$, that allows $\mathcal{S}_A$ to open the commitments later \cite{Unruh10}.  From the remaining $n$ values $(a^0_i,b^0_i)$, $\mathcal{S}_A$ computes Alice's input $(a,b)$ and feeds it to $\mathcal{F}_{\textbf{OLE}}$.

For a dishonest Bob, we have to show the existence of a simulator, $\mathcal{S}_B$, that generates messages on behalf of  honest Alice and extracts Bob's input $x$. We assume that $\mathcal{S}_B$ has full control over  $\mathcal{F}_{\textbf{COM}}$, which means that it has access to Bob's $m$ committed values $(x^0_i, r_i)$;  the input $x$ can be easily extracted from these values. %The rest of the simulation goes according to the output value of the ideal OLE functionality $y$ on the simulator input $x$. {\cv not sure what the last sentence means}

\

\noindent\textbf{Protocol generalization.}  We start by generalizing   the main relation (\ref{eq:main_ingredient}) to Galois Fields of prime-power dimension, $GF(d^M) \text{ for }M>1$. Then, we show how we can obtain a protocol for quantum VOLE. In particular, from $n$ WOLE instances, we are able to generate a VOLE with size proportional to $n$, and we  bound this proportion by the min-entropy value on the WOLE instances.


\subsection{Organization}\label{Intro_organization}
 In Section \ref{Prelim}, we introduce notation and state results and definitions, that we will use in the rest of the paper. In Section \ref{insecureQOLE}, in order to build some intuition, we present a QOLE protocol that is secure only if we consider Bob to be semi-honest; in case Bob is dishonest, its security is compromised. In Section \ref{secureQROLE_overview}, we construct a secure protocol that comprises the first part of our main QOLE protocol presented in Section \ref{qole_protocol}. Next, in Section \ref{secureQROLE_protocol}, we prove the security of the QOLE protocol in the quantum-UC framework.   Finally, in the last Section \ref{sec:protgeneral}, we show how to generalize the presented QOLE protocol to  Galois Fields of prime-power dimensions and we also present a quantum-UC secure protocol achieving VOLE.



\section{Semi-honest QOLE protocol}\label{insecureQOLE}

 In order to build some intuition on the proposed protocol for QOLE, we start by presenting a simpler protocol that is only secure under the semi-honest adversarial model. This semi-honest version leverages the properties of MUBs explored in Section~\ref{Prelim_MUB} and, in particular, the one presented in expression~\eqref{eq:main_relation}. As we saw, given the set of MUBs $\{ \ket{e^x_r} \}_{r\in\mathbb{Z}_d},\ \forall x\in\mathbb{Z}_d$, the operators $V^b_a$ simply permute the elements inside the basis $x$, according to a linear combination of the elements $a$, $b$, $x$ and $r$:

\begin{equation}
V^b_a \ket{e^x_r} = c_{a, b, x, r} \ket{e^x_{ax - b +r}}.
\label{eq:main_ingredient}
\end{equation}

Alice and Bob can use the above property to compute together a linear function $f(x) = ax - b$, where Alice chooses the parameters $a$ and $b$, and Bob chooses the input element $x$. The protocol summarized in Figure~\ref{fig:SH_QOLE}. Bob starts by choosing a basis $x$ and an element $r$ therein, and prepares the state $\ket{e^x_r}$:  the basis choice $x$ plays the role of the input element $x$, and the basis element $r$ is used to enhance Bob's security against a potentially dishonest Alice. Then, he sends the  state $\ket{e^x_r}$ to Alice, who, in turn, applies on it the operator $V^b_a$ and sends back to Bob the resulting state. According to ~\eqref{eq:main_ingredient}, Bob receives $\ket{e^x_{ax - b + r}}$,  measures it in the $x$ basis, and outputs the linear function evaluation $f(x) = ax-b$ by subtracting $r$. Thus, the correctness of the protocol is ensured by expression~\eqref{eq:main_ingredient}.
%\begin{figure}[!h]
%\centering
%\framebox[\linewidth][l]{%
%    \parbox{0.95\linewidth}{%
%    \begin{center}
%        \textbf{Semi-honest QOLE}
%    \end{center}
%    
%    \textbf{Alice's input:} $(a, b) \in \mathbb{Z}^2_d$
%    
%    \textbf{Bob's input:} $x \in\mathbb{Z}_d$
%    
%    \
%    
%    \begin{enumerate}
%     
%        \item Bob  randomly generates $r \in \mathbb{Z}_d$. He prepares and sends the state $\ket{e^x_r}$ to Alice.
%        \item Alice prepares the operator $V^b_a$ according to her inputs $a$ and $b$. She then applies $V^b_a$ to Bob's state: $V^b_a \ket{e^x_r} = c_{x,a,b,r} \ket{e^x_{ax - b + r}}$. She sends the resulting state back to Bob. 
%        \item Bob measures in the  basis  $x$,  subtracts $r$, and outputs the desired result $ax-b=:f(x)$.
%    \end{enumerate}
%    
%    \textbf{Alice's output:} $\bot$
%    
%    \textbf{Bob's output:} $f(x)$
%    }%
%}
%\caption{Semi-honest QOLE protocol.}
%\label{fig:SH_QOLE}
%\end{figure}

\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{\textbf{Semi-honest QOLE}}
            
            \
            
    		\textbf{Alice's input:} $(a, b) \in \mathbb{Z}^2_d$
    
    		\textbf{Bob's input:} $x \in\mathbb{Z}_d$
            
            \
            
		\begin{enumerate}
        \item Bob  randomly generates $r \in \mathbb{Z}_d$. He prepares and sends the state $\ket{e^x_r}$ to Alice.
        \item Alice prepares the operator $V^b_a$ according to her inputs $a$ and $b$. She then applies $V^b_a$ to Bob's state: $V^b_a \ket{e^x_r} = c_{x,a,b,r} \ket{e^x_{ax - b + r}}$. She sends the resulting state back to Bob. 
        \item Bob measures in the  basis  $x$,  subtracts $r$, and outputs the desired result $ax-b=:f(x)$.
    \end{enumerate}
    
    \
    
    \textbf{Alice's output:} $\bot$
    
    \textbf{Bob's output:} $f(x)$
        
        \end{tcolorbox}
    \caption{Semi-honest QOLE protocol.}
    \label{fig:SH_QOLE}
\end{figure}



As far as the security of this protocol is concerned, we can easily see that it is secure against a dishonest Alice.  From her point of view, all the density matrices describing the several possible cases for $x = 0, \ldots, d-1$  are maximally mixed states. Therefore, she cannot know anything about the value of $x$. 

If, moreover, Bob is semi-honest the protocol remains secure. On the other hand, if Bob is dishonest and deviates from the protocol, he is able to find out Alice's inputs $a$ and $b$ with certainty. %His attack is based on his ability to generate entangled states.
In section~\ref{Prelim_MUB} equation~\eqref{eq:bob_attack}, we saw that the generalized Bell basis is generated by Alice's operators, $V^b_a$, i.e. $ \ket{B_{a,b}} = (1 \otimes V^b_a) \ket{B_{0,0}} $,  and Bob can make use of this property in order to extract her inputs $a$ and $b$. His attack can be described as follows:

\begin{enumerate}
    \item Bob prepares the state $\ket{B_{0,0}}$ and sends the second qudit to Alice.
    \item Alice applies her chosen operator $V^b_a$.
    \item Bob measures both qudits in the generalized Bell basis and outputs  $a,b$.
\end{enumerate}

It becomes clear that the protocol is secure only as long as Bob does not deviate from it; a dishonest Bob can break its security by performing the above attack. Therefore, we have to make sure that Bob sticks to the protocol. To achieve this, we apply a \textit{commit-and-open} scheme \cite{DFLSS09} that can be briefly described as follows:  Bob runs step 1. of the Semi-honest QOLE protocol (see Figure~\ref{fig:SH_QOLE}) multiple times, say $m$ in total, for multiple values of $x_i, \text{ and } r_i,\text{ for } i\in [m]$ and commits to these values by means of the functionality $\mathcal{F}_{\textbf{COM}}$ (see Figure~\ref{fig:func_com}). Then, he sends these states to Alice, who, in turn, asks him to disclose his chosen  $x_i$'s and $r_i$'s for some of the $m$ instances that she chooses. The functionality $\mathcal{F}_{\textbf{COM}}$ forwards these committed values to Alice and she measures the corresponding received states in the disclosed bases. She can, thus, verify whether she got the right basis element for all the instances she chose to check. If Bob had used the Bell state $\ket{B_{0,0}}$ in one out of the $m$ instances, then the probability of Alice getting the correct result after measuring the state in the committed basis would be $\frac{1}{d}$. In other words, Bob would get caught with high probability $1-\frac{1}{d}$. Furthermore, if he chooses to attack all the instances, the probability of Alice getting correctly all the results is negligible, i.e. exponentially small in the number of instances, $m$. We explore this in detail in the next section, where we present a  QOLE protocol secure against dishonest adversaries.

\section{QOLE protocol}\label{secureQROLE_overview}

Our QOLE protocol is divided into two main phases: a quantum phase and a classical post-processing phase. The first phase uses quantum communication to generate several instances of OLE with random inputs. These instances may leak some information to the parties, therefore we refer to them as random weak OLE (RWOLE). The second phase is purely classical. It uses the RWOLE instances and extracts one classical OLE instance. The post-processing phase has two phases. It implements a derandomization procedure followed by an extraction phase that serves as a privacy amplification method. The full protocol is presented in Figure~\ref{fig:fullprotocol}.  Before proceeding, it is worth mentioning that we consider that neither dishonest party maliciously aborts the protocol. Indeed, in our setting, such a behaviour does not provide an advantage for learning the other party's input. The only case to abort the protocol is when honest Alice catches Bob cheating during the \textit{commit-and-open} stage.  

In the next sections, we break down the protocol, show its correctness and retrieve some technical lemmas used for the security proof. In section~\ref{secureQROLE_protocol}, we prove the protocol to be secure in the quantum-UC model against static dishonest adversaries.

\

\noindent\textbf{Notation.}  During the RWOLE phase, $\mathbf{F}_0 = (F^0_1,F^0_2 ,\ldots, F^0_n)$ is the vector whose components are the  random variables associated to Alice's functions. Each  $F^0_i$ ranges over the set of affine functions in $\mathbb{Z}_d$ such that $\Pr(F^0_i(x)=a^0_ix+ b^0_i)$ is uniform for all $i\in [n]$. We do not distinguish the set of affine functions in $\mathbb{Z}_d$ from $\mathbb{Z}_d^2$. The classical values $\mathbf{F}_0$ are saved in the Hilbert space $\mathcal{H}_{\mathbf{F}_0}$. The same holds for the derandomization phase, where $\mathbf{F}$ denotes the random variable for Alice's functions in the protocol $\pi^n_{\textbf{WOLE}}$. $\textbf{X}_0$ and $\textbf{Y}_0$ are the random variables for $\textbf{x}_0, \textbf{y}_0 \in \mathbb{Z}^{ n}_d$  in the RWOLE phase. and $\textbf{X}$ and $\textbf{Y}$ the corresponding random variables for $\textbf{x}, \textbf{y} \in \mathbb{Z}^{n}_d$  in the post-processing phase. Also, we use $A'$ and $B'$ to denote the system that a dishonest Alice and Bob, respectively, hold at the end of the execution of the protocol.



%\bibliography{bibforthesis}
%\bibliographystyle{unsrt}
%\end{document}
