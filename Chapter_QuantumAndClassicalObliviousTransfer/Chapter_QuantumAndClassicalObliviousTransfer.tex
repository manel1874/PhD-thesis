%\documentclass[11pt]{report}



%\begin{document}

\chapter{Quantum and Classical Oblivious Transfer}

Secure multiparty computation (SMC) has the potential to be a disruptive technique in the realm of data analysis and computation. It enables several parties to compute virtually any function while preserving the privacy of their inputs. However, most of its protocolsâ€™ security and efficiency relies on the security and efficiency of oblivious transfer (OT). For this reason, it is fundamental to understand the pros and cons of classical and quantum approaches. In this chapter, we start by analysing both the security and efficiency of classical OT protocols. Then, we compare these classical protocols with their quantum analog. However, we note that classical and quantum approaches use different information medium. Also, classical technology is indeed much more mature than quantum technology. These two observations make it dubious how to perform such a comparison. 

In chapter~\ref{chapter_QOT}, we reviewed several quantum OT protocols and, in particular, we explored BBCS-based QOT protocols. Beyond being resistant to quantum computer attacks, these protocols provide a practical way to perform OT within SMC. These are divided into two independent phases: oblivious key phase and transfer phase. The first phase corresponds to a precomputation phase that uses quantum technologies and is independent of the parties input elements ($m_0$, $m_1$ and $b$). The second phase only uses classical communications and is based on the precomputed elements from the first phase (oblivious keys). It can be argued that the precomputation phase is not so hungry-efficient as the transfer phase. This comes from the fact that the precomputation is independent of the parties' inputs and can be started way before starting an SMC execution. Since the classical OT protocols can also be divided into these two phases, we can compare the transfer phase of both quantum and classical approaches. Furthermore, we do not need quantum equipment to be run concurrently witht he SMC execution.




\section{Classical Oblivious Transfer}


In this section, we present the Bellare-Micali OT (BM OT) protocol \cite{BM89} based on public key Diffie-Hellman in order to shed some light on the issues related to classical OT implementations. The security and efficiency issues exposed in this section also apply to most of the major classical protocols \cite{EGL85, NP01, CO15}.

We consider $G_q$ to be a subgroup of $\mathbb{Z}^*_p$ with generator $g$ and order $q$, where $p$ is prime and $p = 2q + 1$. Also, we assume public knowledge on the value of some constant $C\in G_q$. This constant guarantees that Bob follows the protocol. For comparison purposes with quantum OT version presented in Chapter~\ref{chapter_QOT}, we split the BM OT protocol into two phases: precomputation phase and transfer phase. The first phase sets the necessary resources to execute the oblivious transfer in the second phase. The protocol is shown in Fig.~\ref{fig:BMOTProtocol}.


\begin{figure}[h!]
\centering
\begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
                        
    \centerline{$\Pi_{BM}$ \textbf{protocol}}
            
    \
    
    \textbf{Parameters:} $H$ an hash function {\cv Improve}.
    
    \textbf{Alice's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
    
    \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
    
    \
    
    \textit{(Precomputation phase)}
    \begin{enumerate}
         \item Bob randomly generates $k\in [q]$ and computes $g^k$.
         \item Alice randomly generates $r_0, r_1\in [q]$ and computes $g^{r_0}$ and $g^{r_1}$.
    \end{enumerate}
    \textit{(Transfer phase)}
    \begin{enumerate}
    \setcounter{enumi}{2}
        \item Bob sets $PK_b := g^k$. Also, he computes $PK_{1-b} = C \cdot PK_b^{-1}$.
        \item Bob sends both public keys $(PK_0, PK_1)$ to $S$.
        \item Alice checks if $(PK_0, PK_1)$ were correctly generated by computing their product: $C = PK_0 \times PK_1$.
        \item Alice computes and sends to Bob the two tuples: $E_0 = ( g^{r_0}, H(PK_0^{r_0})\oplus m_0 )$ and $E_1 = ( g^{r_1}, H(PK_1^{r_1})\oplus m_1 )$ for some hash function $H$.
        \item Bob is now able to compute $H(PK_b^{r_b})$ and recover $m_b$.
    \end{enumerate} 
    
    \textbf{Alice's output:} $\bot$.
    
    \textbf{Bob's output:} $m_b$.
    
\end{tcolorbox} 
	\caption{Bellare-Micali classical OT protocol divided into two phases \cite{BM89}.}
	\label{fig:BMOTProtocol}
\end{figure}



%\bibliography{bibforthesis}
%\bibliographystyle{unsrt}
%\end{document}
