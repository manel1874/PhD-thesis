%\documentclass[11pt]{report}



%\begin{document}

\chapter{Quantum and Classical Oblivious Transfer}

In this chapter, we compare quantum and classical OT protocols. In chapter~\ref{chapter_QOT}, we reviewed several quantum OT protocols and, in particular, we explored BBCS-based QOT protocols. Beyond being resistant to quantum computer attacks, these protocols provide a practical way to perform OT within a secure multiparty computation (SMC) protocol. They era divided into two independent phases: oblivious key phase and transfer phase. The first phase corresponds to a precomputation phase that uses quantum technologies and is independent of the parties input elements ($m_0$, $m_1$ and $b$). The second phase is only based on classical communications and executes the OT based on the precomputed elements from the first phase (oblivious keys). Consequently, we do not need the quantum equipment to be running concurrently with the SMC execution. 

Furthermore, as we will see, since the classical OT protocols can also be divided into these two phases, we can compare both quantum and classical approaches at the transfer phase.






\section{Classical Oblivious Transfer}


In this section, we present the Bellare-Micali OT (BM OT) protocol \cite{BM89} based on public key Diffie-Hellman in order to shed some light on the issues related to classical OT implementations. The security and efficiency issues exposed in this section also apply to most of the major classical protocols \cite{EGL85, NP01, CO15}.

We consider $G_q$ to be a subgroup of $\mathbb{Z}^*_p$ with generator $g$ and order $q$, where $p$ is prime and $p = 2q + 1$. Also, we assume public knowledge on the value of some constant $C\in G_q$. This constant guarantees that Bob follows the protocol. For comparison purposes with quantum OT version presented in Chapter~\ref{chapter_QOT}, we split the BM OT protocol into two phases: precomputation phase and transfer phase. The first phase sets the necessary resources to execute the oblivious transfer in the second phase. The protocol is shown in Fig.~\ref{fig:BMOTProtocol}.


\begin{figure}[h!]
\centering
\begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
                        
    \centerline{$\Pi_{BM}$ \textbf{protocol}}
            
    \
    
    \textbf{Parameters:} $H$ an hash function {\cv Improve}.
    
    \textbf{Alice's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
    
    \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
    
    \
    
    \textit{(Precomputation phase)}
    \begin{enumerate}
         \item Bob randomly generates $k\in [q]$ and computes $g^k$.
         \item Alice randomly generates $r_0, r_1\in [q]$ and computes $g^{r_0}$ and $g^{r_1}$.
    \end{enumerate}
    \textit{(Transfer phase)}
    \begin{enumerate}
    \setcounter{enumi}{2}
        \item Bob sets $PK_b := g^k$. Also, he computes $PK_{1-b} = C \cdot PK_b^{-1}$.
        \item Bob sends both public keys $(PK_0, PK_1)$ to $S$.
        \item Alice checks if $(PK_0, PK_1)$ were correctly generated by computing their product: $C = PK_0 \times PK_1$.
        \item Alice computes and sends to Bob the two tuples: $E_0 = ( g^{r_0}, H(PK_0^{r_0})\oplus m_0 )$ and $E_1 = ( g^{r_1}, H(PK_1^{r_1})\oplus m_1 )$ for some hash function $H$.
        \item Bob is now able to compute $H(PK_b^{r_b})$ and recover $m_b$.
    \end{enumerate} 
    
    \textbf{Alice's output:} $\bot$.
    
    \textbf{Bob's output:} $m_b$.
    
\end{tcolorbox} 
	\caption{Bellare-Micali classical OT protocol divided into two phases \cite{BM89}.}
	\label{fig:BMOTProtocol}
\end{figure}



%\bibliography{bibforthesis}
%\bibliographystyle{unsrt}
%\end{document}
