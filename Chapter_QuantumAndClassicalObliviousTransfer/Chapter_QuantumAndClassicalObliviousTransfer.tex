%\documentclass[11pt]{report}



%\begin{document}

\chapter{Classical and quantum oblivious transfer}
\label{classical-and-quantum-OT}



Secure multiparty computation (SMC) has the potential to revolutionize data analysis and computation by enabling multiple parties to compute any function while preserving the privacy of their inputs. The security and efficiency of SMC protocols rely heavily on the security and efficiency of oblivious transfer (OT). Thus, it is crucial to understand the advantages and drawbacks of both classical and quantum OT protocols.

In this chapter, we begin by examining the security and efficiency of classical OT protocols. Then, we compare these classical protocols with their quantum counterparts. However, it is important to note that classical and quantum approaches utilize different information medium and that classical technology is more established than quantum technology. These factors raise questions about the validity of comparing the two approaches.

In Chapter~\ref{chapter_QOT}, we reviewed various quantum OT protocols and focused on BBCS-based QOT protocols. These protocols offer a practical solution for performing OT within SMC while being resistant to quantum computer attacks. The protocols are divided into two separate phases: the oblivious key (precomputation) phase and the transfer phase. The oblivious key phase uses quantum technologies and is independent of the parties' input elements ($m_0$, $m_1$ and $b$), while the transfer phase only requires classical communication and is based on the precomputed elements (oblivious keys). It can be argued that the precomputation phase is not so hungry-efficient as the transfer phase, as it is independent of the parties' inputs and can be performed well ahead of an SMC execution. The classical OT protocols can also be divided into these two phases, allowing for a comparison of the transfer phase between quantum and classical approaches. Additionally, no concurrent use of quantum equipment is necessary during the SMC execution.




\section{Classical oblivious transfer}\label{Classical-OT}


Let us start by presenting the Bellare-Micali (BM) OT protocol \cite{BM89} based on public key Diffie-Hellman. This exposition aims to shed some light on the issues related to classical OT implementations. The security and efficiency issues explored in this section also apply to most of the major classical protocols \cite{EGL85, NP01, CO15}.

We consider $\mathbb{G}_q$ to be a subgroup of $\mathbb{Z}^*_p$ with generator $g$ and order $q$, where $p$ is prime and $p = 2q + 1$. Also, we assume public knowledge on the value of some constant $C\in \mathbb{G}_q$. This constant guarantees that Bob follows the protocol. Also, for simplicity, we assume the protocol uses a random oracle described as a function $H$. For comparison purposes with quantum OT version presented in Chapter~\ref{chapter_QOT}, we split the BM OT protocol into two phases: precomputation phase and transfer phase. The first phase sets the necessary resources to execute the oblivious transfer in the second phase. The BM OT protocol $\Pi_{BM}$ is shown in Fig.~\ref{fig:BMOTProtocol}.


\begin{figure}[h!]
\centering
\begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
                        
    \centerline{$\Pi_{BM}$ \textbf{protocol}}
            
    \
    
    \textbf{Alice's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
    
    \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
    
    \
    
    \textit{(Precomputation phase)}
    \begin{enumerate}
         \item Bob randomly generates $k\in \mathbb{Z}_q$ and computes $g^k$.
         \item Alice randomly generates $r_0, r_1\in \mathbb{Z}_q$ and computes $g^{r_0}$ and $g^{r_1}$.
    \end{enumerate}
    \textit{(Transfer phase)}
    \begin{enumerate}
    \setcounter{enumi}{2}
        \item Bob sets $\mathsf{pk}_b := g^k$. Also, he computes $\mathsf{pk}_{b\oplus 1} = C \cdot \mathsf{pk}_b^{-1}$.
        \item Bob sends both public keys $(\mathsf{pk}_0, \mathsf{pk}_1)$ to Alice.
        \item Alice checks if $(\mathsf{pk}_0, \mathsf{pk}_1)$ were correctly generated by computing their product: $C = \mathsf{pk}_0 \times \mathsf{pk}_1$.
        \item Alice computes and sends to Bob the two tuples: $E_0 = ( g^{r_0}, H(\mathsf{pk}_0^{r_0})\oplus m_0 )$ and $E_1 = ( g^{r_1}, H(\mathsf{pk}_1^{r_1})\oplus m_1 )$ for some hash function $H$.
        \item Bob is now able to compute $H(\mathsf{pk}_b^{r_b})$ and recover $m_b$.
    \end{enumerate} 
    
    \textbf{Alice's output:} $\bot$.
    
    \textbf{Bob's output:} $m_b$.
    
\end{tcolorbox} 
	\caption{Bellare-Micali classical OT protocol divided into two phases \cite{BM89}.}
	\label{fig:BMOTProtocol}
\end{figure}

\subsection{Security issues}

The security of the Bellare-Micali (BM) OT protocol depends on both concealing and obliviousness properties. The concealing property is maintained as Bob does not send to Alice any information that reveals his input bit choice $b$. The obliviousness property, on the other hand, relies on Alice's ability to keep the randomly generated elements $r_0$ and $r_1$ confidential. This property is compromised if Bob is able to compute the discrete logarithm of $g^{r_i}$ ($i=0,1$) (discrete logarithm problem).

The hardness of the discrete logarithm problem on cyclic groups is fundamental to several other protocols, making it imperative to understand its limitations. However, it is still unproven whether there exists a polynomial-time algorithm that can compute $r$ from $g^r$ ($r\in\mathbb{Z}_q$) in a general cyclic group $\mathbb{G}_q$ with generator $g$ and order $q$. The security of the BM OT protocol assumes that Bob has limited computational power and is unable to calculate the discrete logarithm of a generic number.

Although the generic discrete logarithm problem is not known to be tractable in polynomial-time, there are specific cases where it is possible to compute it efficiently. Indeed, the security of the discrete logarithm problem in cyclic groups can be compromised if the structure of the group is not robust enough. For instance, if a prime $p$ is randomly generated without ensuring that $p - 1$ contains a big prime $p_b$ in its decomposition, it is possible to use a divide-and-conquer technique \cite{PH78} along with some other methods (Shank's method \cite{S71}, Pollard's rho \cite{P78}, Pollard's lambda  \cite{P78}) to solve the discrete logarithm problem. The efficiency of the algorithms depends on the size of $p_b$; the smaller $p_b$, the faster the algorithm can solve the discrete logarithm problem. To avoid these attacks, it is recommended to use safe primes, i.e., primes of the form $p = 2q + 1$ where $q$ is also prime. However, finding safe primes is computationally more expensive compared to finding regular primes.
 
The size of the prime numbers is also an important consideration. In \cite{ABDGGHHSTVVWZZ15}, it is reported that the number field sieve algorithm can compute the discrete logarithm in a 512-bit group after a week-long precomputation and in just one minute. So, by following this method, after a week-long computation, Bob would be able to find both messages $m_0$ and $m_1$ of the BM OT protocol in one minute. In an SMC scenario based on the Yao approach \cite{Yao82}, where each OT performed corresponds to one input bit of Alice and the chosen group parameters are fixed, Bob would be able to get the keys corresponding to both $0$ and $1$ bit and, consequently, he would be able to discover all Alice's inputs. Hence, at the expense of efficiency, it is necessary to use large prime numbers (2048-bit or larger) that are resistant to these classical attacks.

We have just seen specific examples where it is possible to break the security of the OT protocol using classical techniques. However, the larger threat to the security of OT and many other asymmetric cryptographic protocols such as RSA, elliptic-curve cryptography, and Diffie-Hellman key exchange is posed by quantum computers, which can efficiently solve the general discrete logarithm problem. This was first demonstrated by Peter Shor in his 1995 publication of a quantum algorithm that can solve both the prime factorization and discrete logarithm problems in polynomial time \cite{Sho95}. Therefore, in the BM OT protocol Bob would be able to perform two attacks with the help of a quantum computer:


\

\textbf{Quantum attack 1:}
\begin{enumerate}
    \item Bob computes the discrete logarithm of $g^{r_{b\oplus 1}}$ received from Alice using Shor's algorithm, i.e. $r_{b\oplus 1} = \log_g g^{r_{b\oplus 1}}$.
    \item Bob is then able to compute $H\big((g^{r_b})^k\big) = H(\mathsf{pk}_b^{r_b})$ and $H(\mathsf{pk}_{b\oplus 1}^{r_{b\oplus 1}})$ and get both messages $m_b$ and $m_{b-1}$.
\end{enumerate}

\textbf{Quantum attack 2:}
\begin{enumerate}
    \item Bob computes the discrete logarithm of $\mathsf{pk}_{b\oplus 1}$ with the Shor's algorithm, i.e. $s = \log_g \mathsf{pk}_{b\oplus 1}$.
    \item Bob is then able to compute $H\big((g^{r_b})^k\big) = H(\mathsf{pk}_b^{r_b})$ and $H\big((g^{r_{b\oplus 1}})^s\big) = H(\mathsf{pk}_{b\oplus 1}^{r_{b\oplus 1}})$ and get both messages $m_b$ and $m_{b\oplus 1}$.
\end{enumerate}

The research literature mainly presents two approaches to address this issue: developing protocols with assumptions about the computational power of quantum computers, or developing protocols that utilize quantum technology. The former approach, known as post-quantum cryptography \cite{Bernstein2017}, often requires more demanding public-key cryptography protocols due to the computational assumptions employed. Notably, these assumptions are yet unproven and have only been subject to a few years of scrutiny, making them vulnerable to attack in the near future. The latter approach, referred to as quantum cryptography \cite{Pirandola2020}, provides solutions without relying on asymmetric cryptography, but significantly increases the cost of the necessary technological equipment. It's crucial to note that quantum protocols do not experience the \textit{intercept now, decipher later} attack (everlasting security) because their security is based on quantum theory. Conversely, this type of attack is always a possibility in protocols that rely on computational assumptions.


\subsection{Efficiency issues}


In the previous section, we highlighted that increasing security through mitigation processes always has an impact on efficiency. This is because generating secure primes is more demanding, larger exponents and prime modules result in heavier computations, and post-quantum solutions generally require stronger computational assumptions, leading to increased computational complexity.

Now, let's examine the efficiency limitations of the BM OT protocol. To start, we will consider the operations used in the protocol, including random number generation, modular multiplication, modular inversion, modular exponentiation, hash function evaluation, and XOR operation. Of all these operations, modular exponentiation is the most demanding, meaning that the complexity of BM OT is heavily influenced by the complexity of modular exponentiation. The number of modular exponentiations performed in each phase is summarized in Table~\ref{table:BMOT_mexp}.

\begin{table}[h!]
\centering
\begin{tabular}{lcc}
\toprule
 & Alice & Bob \\
\midrule
\multicolumn{1}{l}{Precomputation phase}   & $2$  & $1$  \\
\multicolumn{1}{l}{Transfer phase} & $2$  & $1$\\
\bottomrule
\end{tabular}
\caption{Number of modular exponentiations in the BM protocol for each phase.}
\label{table:BMOT_mexp}
\end{table}


One of the most efficient ways to perform general modular exponentiation with $n$-bit numbers is to use a combination of square-and-multiply algorithm and Karatsuba multiplication. The former has a complexity of $\mathcal{O}(n)$ multiplications, while the latter has a complexity of $\mathcal{O}(n^{1.58})$. The overall complexity of this method is $\mathcal{O}(n^{2.58})$ $n$-bit operations \cite{MVV01}. To overestimate the rate of OT generation, we'll consider the time (in CPU cycles) required to perform all modular exponentiation operations. The rate can be calculated using the following expression:
\begin{equation}
\label{eq:nOTs}
\Big( \frac{C_{mexp}}{C_{cycles}} \times N_{mexp} \Big)^{-1}
\end{equation}
where $C_{mexp}$ is the number of CPU cycles required to perform one modular exponentiation, $C_{cycles}$ is the CPU frequency (number of cycles per second), and $N_{mexp}$ is the number of modular exponentiations performed in the OT implementation. It's important to note that this expression only provides an overestimation, as it depends on both the implementation of the modular exponentiation operation and the CPU frequency being used.





Given a standard CPU operating at 2.5 GHz ($C_{cycles} = 2.5 \times 10^9$ cycles per second) and an efficient implementation of modular exponentiation ($C_{mexp} \sim 400,000$ CPU cycles) \cite{G11}, the BM OT protocol could perform at most $\sim 1041$ BM OTs per second, as shown in Fig.~\ref{fig:nOTsplot}.
\begin{figure}[]
\centering
\includegraphics[width=1\textwidth]{Chapter_QuantumAndClassicalObliviousTransfer/nOTperSeccond.png}
\caption{Plot of expression (\ref{eq:nOTs}) on the overestimation of OT rate against the number of modular exponentiation operations required per OT.}
\label{fig:nOTsplot}
\end{figure}
This, however, is a loose overestimation of the number of OTs per second, as it only takes into account the computational complexity of modular exponentiation and assumes that other operations have minimal impact on computation time. Therefore, the actual OT rate must be lower.

For comparison, a study in \cite{ALSZ13} reported that it takes around $18$ ms to generate a Naor-Pinkas OT \cite{NP01} which requires $5$ modular exponentiations, yielding a rate of $56$ OTs per second. These OT rates pose a serious challenge for SMC protocols that rely on OT, such as the Yao SMC protocol \cite{Yao82}. The Yao protocol uses boolean circuits to compute a desired functionality privately and requires half the number of input wires as the number of required OTs. Using the rough OT rate estimation, the OT phase of the Yao protocol with a $32,000$ input boolean circuit would take at least $16$ seconds, and around $2$ minutes and $23$ seconds using Naor-Pinkas OT rate. These execution times can become impractical in deployment environments that require several rounds of circuit evaluation and require higher OT rates.



\subsection{OT extension protocols} \label{Ext-OT}

To improve the efficiency of OT, one potential solution is to replace the computation-intensive asymmetric cryptography with more efficient symmetric cryptography. Symmetric cryptography has the advantage of being faster than asymmetric cryptography. In addition, all known quantum attacks to symmetric cryptography based on the Grover's algorithm only provide a quadratic advantage over classical approaches, which can be mitigated by doubling the size of the symmetric keys \cite{Bernstein2017}. However, despite its efficiency, symmetric cryptography is not enough for OT because it does not meet the asymmetric cryptographic assumptions required by Impagliazzo and Rudich's result \cite{IR99}. Hence, OT cannot be performed solely with symmetric cryptography methods.

To overcome the limitations imposed by Impagliazzo and Rudich's result \cite{IR99} on the use of solely symmetric cryptography for OT, researchers have developed hybrid protocols that combine both symmetric and asymmetric cryptography. Beaver \cite{B96} introduced the idea of extending the number of OTs by using symmetric cryptography, once a small number of base OTs are established using asymmetric cryptography. Although Beaver's original protocol was inefficient, it paved the way for more efficient implementations \cite{IKNP03, N07, NNOB12, ALSZ13, ALSZ15}. Currently, one of the most efficient protocols can generate about $10$ million OTs in $2.62$ seconds \cite{ALSZ13}. The security of these protocols mainly relies on the security of the base OT protocol and the use of quantum secure symmetric tools. However, it's important to note that the protocol analyzed in Section~\ref{Ext-OT_comp} \cite{ALSZ13} is not secure against malicious parties and should only be used in a semi-honest environment. To ensure security against malicious parties, extra consistency check phases are necessary, increasing the complexity of the protocol \cite{ALSZ15, KOS15}, as discussed in Section~\ref{Mal-Ext-OT_comp}.



\section{Oblivious transfer complexity analysis} \label{HQOT_comp}

In this section, we compare the complexity of the transfer phase of an optimized version of the BBCS-based QOT protocols ($\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ and $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$) presented before and several well known classical protocols. We start by explaining the optimized version..

\subsection{Optimization}\label{O-OT}

Recall that both $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ and $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ can be divided into two phases: the oblivious key distribution phase (we also call it a \textit{precomputation} phase) and the transfer phase. It is interesting to note that both protocols follow the same steps in the transfer phase. We present the transfer phase of both protocols in Figure~\ref{fig:BBCS_Transfer}. We slightly rewrite the protocol by using only one hash function ($H$ describes a random oracle) instead of two random hash functions $f_0$ and $f_1$. This is done for comparison purposes and because, in practice, $H$ is implemented as a specific hash function, such as SHA.

\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{$\Pi^{\textbf{BBCS}}$ \textbf{protocol}}
            
            \
            
            \textbf{Alice's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
            
            \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
            
            \
            

            
            \textit{Precomputation phase}: \textcolor{gray}{Alice and Bob generate an oblivious key $(\mathsf{ok}^{\mathsf{A}}, (\mathsf{ok}^{\mathsf{B}}, \mathsf{e}^{\mathsf{B}}))$ according to the corresponding procedure. $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ as in Figure~\ref{fig:BBCS_COM} and $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ as in Figure~\ref{fig:BBCS_Bounded}.}
            
            \
            
            \textit{Transfer phase}:
            \begin{enumerate}
            \setcounter{enumi}{4}
                \item Bob defines $I_0 = \{ i : \mathsf{e}^{\mathsf{B}}_i = 0 \}$ and $I_1 = \{ i : \mathsf{e}^{\mathsf{B}}_i = 1 \}$ and sends the pair $(I_b, I_{b\oplus 1})$ to Alice.
                \item Alice computes the pair of strings $(s_0, s_1)$ as $s_i = m_i \oplus H(\mathsf{ok}^{\mathsf{A}}_{I_{b\oplus i}})$ and sends to Bob.
                \item Bob computes $m_b = s_b \oplus  H(\mathsf{ok}^{\mathsf{B}}_{I_0})$. 
            \end{enumerate}
            
            \
            
        \textbf{Alice's output:} $\bot$.
        
        \textbf{Bob's output:} $m_b$.
        
        \end{tcolorbox}
    \caption{Transfer phase of BBCS-based QOT protocols in the $\mathcal{F}_{\mathbf{COM}}-$hybrid model and bounded-quantum-storage model.}
    \label{fig:BBCS_Transfer}
\end{figure}

In the first communication round of the protocol in Figure~\ref{fig:BBCS_Transfer}, Bob sends two sets $(I_b, I_{b\oplus 1})$ to Alice (Step 5). This can be optimized by only sending one set $(I_b)$, as Alice can determine its complement ($\overline{I_b} = I_{b\oplus 1}$) with just one set. This leads to the optimized protocol ($\Pi^{\textbf{BBCS}}_{\textbf{O}}$) shown in Figure~\ref{fig:BBCS_Transfer-optimized}. This optimization results in lower bandwidth requirements compared to the original transfer phase.

The size of the sets can be identified by a symmetric security parameter $\kappa$, as they define the keys ($\mathsf{ok}_{I_i}$, $i=0,1$) used in the hash function $H$. For comparison, we consider $\kappa = 128$. Also, the messages $m_0$ and $m_1$ can be viewed as garbled circuit keys, with a size of $l = 128, 192$ or $256$. If we assume $l \sim \kappa$, the same number of bits are required. This means that in Step 5, Bob only needs to send $l$ bits to Alice, resulting in a reduction of one fourth in the number of bits sent during the transfer phase.

\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{$\Pi^{\textbf{BBCS}}_{\textbf{O}}$ \textbf{protocol}}
            
            \
            
            \textbf{Alice's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
            
            \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
            
            \
            

            
            \textit{Precomputation phase}: \textcolor{gray}{Alice and Bob generate an oblivious key $(\mathsf{ok}^{\mathsf{A}}, (\mathsf{ok}^{\mathsf{B}}, \mathsf{e}^{\mathsf{B}}))$ according to the corresponding procedure. $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ as in Figure~\ref{fig:BBCS_COM} and $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ as in Figure~\ref{fig:BBCS_Bounded}.}
            
            \
            
            \textit{Transfer phase}:
            \begin{enumerate}
            \setcounter{enumi}{4}
                \item Bob defines $I_0 = \{ i : \mathsf{e}^{\mathsf{B}}_i = 0 \}$ and $I_1 = \{ i : \mathsf{e}^{\mathsf{B}}_i = 1 \}$ and \textbf{sends only} $I_b$ to Alice.
                \item Alice computes the pair of strings $(s_0, s_1)$ as $s_i = m_i \oplus H(\mathsf{ok}^{\mathsf{A}}_{I_{b\oplus i}})$ and sends to Bob.
                \item Bob computes $m_b = s_b \oplus  H(\mathsf{ok}^{\mathsf{B}}_{I_0})$. 
            \end{enumerate}
            
            \
            
        \textbf{Alice's output:} $\bot$.
        
        \textbf{Bob's output:} $m_b$.
        
        \end{tcolorbox}
    \caption{Transfer phase of BBCS-based QOT protocols in the $\mathcal{F}_{\mathbf{COM}}-$hybrid model and bounded-quantum-storage model.}
    \label{fig:BBCS_Transfer-optimized}
\end{figure}


%%%% chatGPT

To fairly compare the transfer phase of the $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ protocol with other classical protocols, we divide classical protocols into precomputation and transfer phases. All steps that are independent of the messages ($m_0$ and $m_1$) and the bit choice ($b$) are considered part of the precomputation phase, while others are included in the transfer phase. The transfer phase is more important to optimize as it is executed during the Yao GC protocol, while the precomputation phase can be performed beforehand.

We stress we will only compare the complexity of different protocols' transfer phase because their precomputation phase rely on different technologies. Since quantum technologies are still in their infancy and constantly evolving, it is difficult to compare the efficiency with classical approaches. However, the oblivious key phase of the $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ protocol has a linear time complexity in all its security parameters, as shown by Lemus et al. \cite{Lemus20}. The time complexity of $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ is $\mathcal{O}(\kappa(2l + t))$, where $\kappa$ is the security parameter of the hash-based commitments, $2l$ is the number of qubits used to generate the oblivious keys, and $t$ is the number of testing qubits.

\subsection{Classical OT} \label{C-OT_comp}

In section \ref{Classical-OT}, we divided the well known Bellare-Micali protocol in these two phases and we observed that it uses three exponentiations during the transfer phase. In Table~\ref{table:ClassicalOT_comparison}, we present the number of required modular exponentiations and communication rounds during the transfer phase of four well known classical protocols that have their security based on the computational hardness of the Discrete Logarithm problem. 

\begin{table}[h!]
\centering
\begin{tabular}{lcc}
\toprule
Protocol & Exponentiation & Comm. rounds \\
\midrule
EGL \cite{EGL85}      & $3$              & $2$\\ 
BM  \cite{BM89}     & $3$              & $2$ \\ 
NP  \cite{NP01}     & $2$             & $2$  \\ 
SimpleOT \cite{CO15} & $1$              & $2$           \\
\bottomrule
\end{tabular}
\caption{Number of modular exponentiation operations and communication rounds executed during the transfer phase of four classical protocols.}
\label{table:ClassicalOT_comparison}
\end{table}

From Table~\ref{table:ClassicalOT_comparison}, we see that the most efficient protocol (SimpleOT \cite{CO15}) still requires one exponentiation operation and $2$ communication rounds. From the above formula (\ref{eq:nOTs}) and setting $C_{mcyles} = 2.5 \times 10^9$, $C_{mexp} = 400\,000$ and $N_{mexp} = 1$, we get an overestimation of around $6 000$ OT per second. Comparing with the rate achieved by OT extension protocols ($10$ million OT in $2.62$ s), it is still very inefficient.

This means current classical OT protocols have a computational complexity limited by $\mathcal{O}(n^{2.58})$ bit operations due to modular exponentiation. The $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ protocol only depends on simple bit operations (XOR, truncation and comparison), meaning its computational complexity is linear in the length of the messages $\mathcal{O}(n)$.

Despite their security guarantees, none of the classical OT protocols discussed are secure against quantum computer attacks. To achieve this level of security, post-quantum approaches must be adopted, which may result in higher computational demands \cite{PST19}. For example, the use of Kyber key encapsulation based on the module learning with errors (M-LWE) problem \cite{CrystalKyber17} in a LAN network results in a rate of only 41 OT per second (24 ms per OT), as reported in \cite{MR19}. This rate is even lower than the rate of 56 OT per second achieved by the Naor-Pinkas protocol \cite{NP01} reported in \cite{ALSZ13}. The NTRU post-quantum encryption system \cite{NTRU} was used in \cite{NTRUOT1, NTRUOT2} to develop a 1-out-of-$n$ OT, which was compared with the SimpleOT protocol \cite{CO15}. Although the individual sides are more efficient in NTRU OT, the overall protocol is still less efficient, with a rate of 728 OT per second ($1.372$ ms per OT) for the highest security level compared to 1375 OT per second ($0.727$ ms per OT) using SimpleOT. It is important to note that these protocols are still vulnerable to \textit{intercept now, decipher later} attacks as they rely on computational assumptions that are only believed to be secure against quantum computer attacks and not proven.


\subsection{OT extension} \label{Ext-OT_comp}

As we explained in section \ref{Ext-OT}, several techniques based on an hybrid symmetric-asymmetric approach were developed as a way to increase the OT execution rate. These techniques use a small number $\kappa$ ($=128$) of base OT protocols (e.g. EGL, BM, NP, SimpleOT) and extend this resource to $m$ ($=10\,000\,000$) OT executions, where $ m >> \kappa$. 

Again, to fairly compare $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ with OT extension protocols, we divide them into precomputation and transfer phases. In this section, we compare the communication and computational complexity of $m$ executions of $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ to one execution of an OT extension protocol, as the latter generates a predetermined number ($m$) of OTs. We compare $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ with the semi-honest ALSZ13 protocol and then with the maliciously secure KOS15 protocol.

\subsubsection{ALSZ13 comparison}

\begin{figure}[t]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
                        
			\centerline{\textbf{ALSZ13 OT extensions protocol \citep{ALSZ13}}}
            
			\ 

			\textbf{Alice's input:} $m$ pairs $(x^0_j, x^1_j),\, \forall j\in[m]$ of $l$-bit strings.
            
			\textbf{Bob's input:} $m$ selection bits $\bm{r} = (r_1, ..., r_m)$.

			\
			
			\textit{Initial OT phase (Precomputation phase)}
    \begin{enumerate}
         \item Alice randomly generates a string $\bm{s} = (s_1, ..., s_\kappa)$.
         \item Bob randomly chooses $\kappa$ pairs of $\kappa$-bit strings $\{(\bm{k}^0_i, \bm{k}^1_i)\}^\kappa_{i=1}$.
         \item Bob and Alice execute $\kappa$ base OTs, where Alice plays the role of the receiver with input $\bm{k}$ and Bob plays the role of the sender with messages $(\bm{k}^0_i, \bm{k}^1_i),\, \forall i\in[\kappa]$.
    \end{enumerate}
    \textit{OT extension phase (Transfer phase)}
    \begin{enumerate}
    \setcounter{enumi}{3}
        \item Bob applies a pseudorandom number generator $G$ to $\bm{k}^0_i$, i.e. $\bm{t}^i = G(\bm{k}^0_i)$. Computes $\bm{u}^i = \bm{t}^i \oplus G(\bm{k}^1_i) \oplus \bm{r}$ and sends $\bm{u}^i$ to Alice for every $ i\in[\kappa]$.
        \item Alice computes $\bm{q}^i = (s_i \cdot \bm{u}^i) \oplus G(\bm{k}^{s_i}_i)$.
        \item Alice sends $(y^0_j, y^1_j)$ for every $j\in[m]$, where $y^0_j = x^0_j\oplus H(j,\bm{q}_j)$, $y^1_j = x^1_j\oplus H(j,\bm{q}_j\oplus \bm{s})$ and $\bm{q}_j$ is the $j$-th row of the matrix $Q = [ \bm{q}^1 | ...| \bm{q}^\kappa]$. Note that, in practice, it is required to transpose $Q$ to access its $j$-th row.
        \item Bob computes $x^{r_j}_j = y^{r_j}_j \oplus H(j, \bm{t}_j)$.
    \end{enumerate} 
    
				\textbf{Alice's output:} $\bot$.
    
				\textbf{Bob's output:} $(x^{r_1}_1, ..., x^{r_m}_m)$.

        
        \end{tcolorbox}
    \caption{Precomputation and transfer phases of OT extensions protocol presented in \cite{ALSZ13}.}
    \label{fig:ALSZ13Protocol}
\end{figure}

Let's consider the OT extension protocol proposed in \cite{ALSZ13} (ALSZ13), as illustrated in Figure~\ref{fig:ALSZ13Protocol}. At the time of writing, this protocol reports the fastest implementation with 10 million OTs generated in just 2.68 seconds. The ALSZ13 protocol is divided into two phases: an initial OT phase and an OT extension phase. For comparison purposes, we will focus solely on the second phase, which aligns with our distinction between the precomputation and transfer phases.

In Tables~\ref{table:CvsQ_OT_comparison_computation} and~\ref{table:CvsQ_OT_comparison_communication}, we present a comparison of the computational and communication complexity of the OT extension protocol (ALSZ13) and $\Pi^{\textbf{BBCS}}_{\textbf{O}}$. In Table~\ref{table:CvsQ_OT_comparison_computation}, PRG refers to a pseudorandom generator, $\kappa$ is the number of base OTs executed during the precomputation phase of the OT extension, $m$ represents the total number of OTs, and $l$ is the length of the OT strings. It is assumed that $l \sim \kappa$ have a similar magnitude, as the key length used in the garbled circuits is $l = 128, 192$, or $256$, while $\kappa = 128$ \cite{ALSZ13}. Now, we justify the analysis presented in Tables~\ref{table:CvsQ_OT_comparison_computation} and~\ref{table:CvsQ_OT_comparison_communication}. 

Regarding the ALSZ13 protocol, for every $i\in[\kappa]$, Bob computes two PRGs in step 4 and Alice computes one PRG in step 5. This accounts for $3\kappa$ PRG executions. For every $j \in[m]$, Alice computes two hash functions in step 6 and Bob computes one hash function. This accounts for $3m$ hash functions. For every $i\in[\kappa]$, Bob computes two $m-$bit XOR operations in step 4 and Alice computes one $m-$bit XOR operation. For every $j \in[m]$, Alice computes two $l-$bit XOR operations in step 6 and Bob computes one $l-$bit XOR operation in step 7. Also, for every $j \in[m]$, Alice computes one $\kappa-$bit XOR operation in step 6. This accounts for $3m\kappa + 3ml + m\kappa$ bitwise XOR operations. For every $i\in[\kappa]$, Alice computes one $m-$bit AND operation in step 5. Finally, Alice has to perform a matrix inversion which accounts for around $m\log m$ bit operations. The communication complexity is given by the following elements: Bob sends an $m-$bit vector for every $i\in[\kappa]$ and Alice sends two $l-$bit messages for every $j \in[m]$. This accounts for $2ml + m\kappa$ bits sent.

Regarding the $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ protocol, for every execution of the protocol, Alice computes two hash functions in step 6 and Bob computes one hash function in step 7. This accounts for $3m$ hash functions. Also, Alice computes two $l-$bit XOR operations in step 6 and Bob computes one $l-$bit XOR operation in step 7. This accounts for $3ml$ bitwise XOR operations. For every execution of the protocol, Alice performs $2\kappa$ bitwise comparisons in step 5. Also, Alice computes two $\kappa-$bit truncation in step 6 and Bob computes one $\kappa-$bit truncation in step 7. The communication complexity is given by the following elements: Bob sends a $\kappa-$bit vector and Alice sends two $l-$bit messages, for every execution of the protocol. This accounts for $2ml + m\kappa$ bits sent.

\begin{table}[h!]
\centering
\begin{tabular}{lcc}
\toprule
Operation & ALSZ13 & $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ \\
\midrule
PRG (AES)     & $3\kappa$              & -\\ 
Hash (SHA-1)    & $3m$              & $3m$ \\ 
Bitwise XOR      & $3 m \kappa + 3ml + m\kappa$             & $3ml$  \\ 
Bitwise AND  & $m\kappa$              & -           \\
Matrix transposition & $m\log m$              & -           \\
Bitwise comparison & -             & $2m\kappa$           \\
Bitwise truncation & -            & $3m\kappa$           \\
\bottomrule
\end{tabular}
\caption{Computational complexity comparison between ALSZ13 \cite{ALSZ13} OT extension protocol and $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ protocol from section~\ref{O-OT}.}
\label{table:CvsQ_OT_comparison_computation}
\end{table}

\begin{table}[h!]
\centering
\begin{tabular}{lcc}
\toprule
 & ALSZ13 & $\Pi^{\textbf{BBCS}}_{\textbf{O}}$  \\
\midrule
\multicolumn{1}{l}{Bits sent }   & $2ml  + m\kappa$   & $2ml + m\kappa $  \\
\bottomrule
\end{tabular}
\caption{Communication complexity comparison between ALSZ13 \cite{ALSZ13} OT extension protocol and $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ protocol from section~\ref{O-OT}.}
\label{table:CvsQ_OT_comparison_communication}
\end{table}

The communication complexity is exactly the same in both protocols: $\sim 3ml$. So, the OT extension protocol does not have any advantage over $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ during the communication phase. Regarding their computational complexity, we have to compare the binary operations executed by each protocol.

Firstly, we can see that $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ transfer phase is asymptotically more efficient than ALSZ13 OT extension transfer phase. The computational complexity of OT extension is not linear in the number of OT executions, $\mathcal{O}(m\log m)$, whereas it is linear in the case of $\Pi^{\textbf{BBCS}}_{\textbf{O}}$, $\mathcal{O}(m)$. Now, let us compare the binary operations between each protocol. Denote by $B_{\text{op}}^\text{ALSZ13}$ and $B_{\text{op}}^\text{BBCS}$ the number of binary operations executed by ALSZ13 and $\Pi^{\textbf{BBCS}}_{\textbf{O}}$, respectively. As both protocols execute $3m$ hash functions, we do not take into account their execution. Also, assuming that $\kappa \sim l$, $B_{\text{op}}^\text{ALSZ13}$ is roughly given by,
\begin{eqnarray*}
    B_{\text{op}}^\text{ALSZ13} &=& 3\kappa + 3m\kappa + 3 m l + m\kappa + m\kappa + m \log m \\
    &=& 8 m \kappa + 3 \kappa + m\log m 
\end{eqnarray*}
and $B_{\text{op}}^\text{BBCS} = 8 m \kappa$. Here, we simplify and assume that $3\kappa$ PRGs executions consume only $3\kappa$ bit operations. Therefore, ALSZ13 has more $B_{\text{op}}^\text{ALSZ13} - B_{\text{op}}^\text{BBCS}  \geq m\log m $ binary operations than the transfer phase of $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ protocol. 

%Firstly, we can see that $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ transfer phase is asymptotically more efficient than ALSZ13 OT extension transfer phase. The computational complexity of OT extension is not linear in the number of OT executions, $\mathcal{O}(m\log m)$, whereas it is linear in the case of $\Pi^{\textbf{BBCS}}_{\textbf{O}}$, $\mathcal{O}(m)$. Thus, for a bounded value $l$, $m\log m > ml$ asymptotically. However, in practice, for $l \sim 128$, it would take around $m>10^{50}$ Oblivious Transfers to actually have $m\log m > ml$. Secondly, when comparing $ml$ bit operations with $3m$ SHA$-1$ computations, we conclude that $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ uses less bit operations. Each execution of SHA$-1$ \cite{NISTSHA} requires 80 rounds of several bit operations. If we underestimate the cost of each round and we assume it only requires two bit operations, we get that ALSZ13 OT extension protocol requires at least $3 \times 80\times 2 m = 480 m > ml, \, \forall m$. 

%Let us plot in Fig.~\ref{fig:CvsQ_OT_comparison} the number of bit operations for both protocols. In the case of ALSZ13 OT extension, we underestimate the number of bit operations by considering that SHA$-1$ only costs $480m$ bit operations and that PRG (AES) does not involve any cost. 

%\begin{figure}[!t]
%\centering
%\includegraphics[width=0.5\textwidth]{O-OTVsEXT_OT.png}
%\caption{Bit operation comparison between the transfer phase of O-OT and Extension %OT protocols.}
%\label{fig:CvsQ_OT_comparison}
%\end{figure}

From the results of our comparison, we can conclude that the transfer phase of $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ is competitive with the corresponding phase of the semi-honest ALSZ13 protocol, and has the potential to be even more efficient. Furthermore, the performance of $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ transfer phase is achieved while providing stronger security guarantees. Unlike the ALSZ13 protocol, which relies on computational assumptions of the base OT, $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ has been proven secure against quantum computers. Moreover, while ALSZ13 is a semi-honest protocol (assumes well-behaved parties that follow the protocol), $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ protocol is secure against any corrupted party. To obtain a fair comparison, it is appropriate to consider OT extension protocols that are secure against malicious parties. The work developed in \cite{IKNP03} presented the first protocol in the malicious scenario, which was latter optimised by KOS15 \cite{KOS15} and ALSZ15 \cite{ALSZ15}. Both optimizations carry out one run of the semi-honest OT extension presented in ALSZ13 plus some consistency checks. The protocol presented in \cite{KOS15} adds to ALSZ13 a \textit{check correlation} phase after the transfer phase and the protocol presented in \cite{ALSZ15} adds a \textit{consistency check} phase during the transfer phase. This means that both malicious protocols' transfer phases have greater computational and communication complexity when compared with ALSZ13. Therefore, we can infer that the transfer phase of $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ has lower computational and communication complexity than its malicious classical equivalents. In the next step, we compare the KOS15 protocol \cite{KOS15} with $\Pi^{\textbf{BBCS}}_{\textbf{O}}$.


\subsubsection{KOS15 comparison}\label{Mal-Ext-OT_comp}

KOS15 protocol is very similar to ALSZ13, but it includes an additional phase called \textit{check correlation} phase. This phase ensures that the receiver is well behaved and does not cheat.  In Figure~\ref{fig:K15Protocol}, it is presented the KOS15 protocol that generates $m$ $l$-bit string OT out of $\kappa$ base OT, with computational security given by $\kappa$ and statistical security given by $w$. Note that, in Figure~\ref{fig:K15Protocol}, we join all the subprotocols presented in the original paper: $\prod^{\kappa, m'}_{\textsc{COTe}}$, $\prod^{\kappa, m}_{\textsc{ROT}}$ and $\prod^{\kappa, m}_{\textsc{DeROT}}$. Also, they identify $\mathbb{Z}^\kappa_2$ with the finite field $\mathbb{Z}_{2^\kappa}$ and use $``\cdot"$ for multiplication in $\mathbb{Z}_{2^\kappa}$. For example, the element $\boldsymbol{t}_j$ in $\sum_{j=1}^{m'} \boldsymbol{t}_j \cdot \chi_j$ (Figure~\ref{fig:K15Protocol}, step $10$) should be considered in $\mathbb{Z}_{2^\kappa}$.

\begin{figure}
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
                        
			\centerline{\textbf{KOS15 OT extensions protocol \citep{KOS15}}}
            
			\ 

    \textbf{Alice's input:} $m$ pairs $(x^0_j, x^1_j),\, \forall j\in[m]$ of $l$-bit strings.
    
    \textbf{Bob's input:} $m$ selection bits $\boldsymbol{r} = (r_1, ..., r_m)$.
    
    \
    
    \textit{Initial OT phase (Precomputation phase)}
    \begin{enumerate}
         \item Alice randomly generates a string $\boldsymbol{s} = (s_1, ..., s_\kappa)$ and Bob randomly chooses $\kappa$ pairs of $\kappa$-bit strings $\{(\boldsymbol{k}^0_i, \boldsymbol{k}^1_i)\}^\kappa_{i=1}$.
         \item Bob and Alice execute $\kappa$ base OTs. Alice plays the role of the receiver with input $\boldsymbol{s}$ and Bob plays the role of the sender with messages $(\boldsymbol{k}^0_i, \boldsymbol{k}^1_i),\, i\in[\kappa]$.
         \item Bob applies a pseudorandom number generator $G$ to $\boldsymbol{k}^0_i$ and $\boldsymbol{k}^1_i$: $\boldsymbol{t}^i = G(\boldsymbol{k}^0_i)$ and $\boldsymbol{t}^i_1 = G(\boldsymbol{k}^1_i)$. Also, set $\boldsymbol{T}^i = \boldsymbol{t}^i \oplus \boldsymbol{t}^i_1$.
         \item Alice applies $G$ to $\boldsymbol{k}^{s_i}_i$ and sets $\boldsymbol{g}^{s_i}_i = G(\boldsymbol{k}^{s_i}_i)$.
    \end{enumerate}
    \textit{OT extension phase (Transfer phase)}
    
    \textit{\hspace{0.25cm} Extend}
    \begin{enumerate}
    \setcounter{enumi}{4}
        \item Bob generates random elements $r_j$, for $r\in [m+1, m']$ and resize $\boldsymbol{r} = (r_1, ..., r_m, r_{m+1}, ..., r_{m'})$, where $m' = m + (\kappa + w)$.
        \item Bob computes $\boldsymbol{u}^i = \boldsymbol{T}^i \oplus \boldsymbol{r}$ and sends $\boldsymbol{u}^i$ to Alice for every $i\in[\kappa]$.
        \item Alice computes $\boldsymbol{q}^i = (s_i \times \boldsymbol{u}^i) \oplus \boldsymbol{g}^{s_i}_i$ for every $i\in[\kappa]$.
    \end{enumerate}
    \textit{\hspace{0.25cm} Check correlation}
    \begin{enumerate}
    \setcounter{enumi}{7}
        \item Sample $(\chi_1, ..., \chi_{m'})\leftarrow \mathcal{F}_{\text{Rand}}(\mathbb{F}^{m'}_{2^\kappa})$.
        \item Bob computes $x = \sum_{j=1}^{m'} r_j \cdot \chi_j$ and $t = \sum_{j=1}^{m'} \boldsymbol{t}_j \cdot \chi_j$, where $\boldsymbol{t}_j$ is the $j$-th row of the matrix $[ \boldsymbol{t}^1 | ...| \boldsymbol{t}^\kappa]$ and sends these to Alice.
        \item Alice computes $q = \sum_{j=1}^{m'} \boldsymbol{q}_j \cdot \chi_j$, where $\boldsymbol{q}_j$ is the $j$-th row of the matrix $Q = [ \boldsymbol{q}^1 | ...| \boldsymbol{q}^\kappa]$, and checks that $t = q + r\cdot \boldsymbol{s}$. If the check fails, output \textsc{Abort}, otherwise continue. %Alice outputs $\Delta$, $\{\boldsymbol{q}_j\}_{j\in[m]}$ and Bob outputs $\{\boldsymbol{t}_j, r_j\}_{j\in [m]}$.
    \end{enumerate} 
    
    \textit{\hspace{0.25cm} Randomize and encrypt}
    \begin{enumerate}
    \setcounter{enumi}{10}
        \item Alice sends $(y^0_j, y^1_j)$ for every $j\in[m]$, where $y^0_j = x^0_j\oplus H(j,\boldsymbol{q}_j)$, $y^1_j = x^1_j\oplus H(j,\boldsymbol{q}_j\oplus \boldsymbol{s})$. % and $\boldsymbol{q}_j$ is the $j$-th row of the matrix $Q = [ \boldsymbol{q}^1 | ...| \boldsymbol{q}^\kappa]$. Note that, in practice, it is required to transpose $Q$ to access its $j$-th row.
        \item Bob computes $x^{r_j}_j = y^{r_j}_j \oplus H(j, \boldsymbol{t}_j)$.
    \end{enumerate} 
    
    \textbf{Alice's output:} $\bot$.
    
    \textbf{Bob's output:} $(x^{r_1}_1, ..., x^{r_m}_m)$.

        
        \end{tcolorbox}
    \caption{Precomputation and transfer phases of OT extensions protocol presented in \cite{KOS15}.}
    \label{fig:K15Protocol}
\end{figure}

\begin{table}
\centering
\begin{tabular}{lcc}
\toprule
Operation & KOS15 & $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ \\
\midrule
Hash (SHA-1)    & $3m$              & $3m$ \\ 
Bitwise XOR      & $3 m\kappa + 3ml + m\kappa$             & $3ml $  \\ 
Bitwise AND  & $m\kappa$              & -           \\ 
Matrix transposition & $m\log m$              & -           \\ 
Bitwise comparison & -             & $2ml$           \\ 
Bitwise truncation & -            & $3ml$           \\ 
$\kappa$-bit additon & $3(m + (\kappa + w))\kappa$ & - \\ 
$\kappa$-bit mult & $2(m + (\kappa + w))\kappa^{1.58}$ & - \\ 
\bottomrule
\end{tabular}
\caption{Computational complexity comparison between KOS15 \cite{KOS15} OT extension protocol and $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ protocol from section~\ref{O-OT}.}
\label{table:complexity}
\end{table}

\begin{table}[h!]
\centering
\begin{tabular}{lcc}
\toprule
 & KOS15 & $\Pi^{\textbf{BBCS}}_{\textbf{O}}$  \\
\midrule
\multicolumn{1}{l}{Bits sent }   & $2ml  + m\kappa + \kappa$   & $2ml + m\kappa $  \\
\bottomrule
\end{tabular}
\caption{Communication complexity comparison between KOS15 \cite{KOS15} OT extension protocol and $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ protocol from section~\ref{O-OT}.}
\label{table:communication}
\end{table}



The KOS15 protocol, like $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ and ALSZ13, begins with a precomputation phase that can be performed prior to the actual OT computation. However, the KOS15 paper \cite{KOS15} originally carried out the computation of PRGs $G$ during the OT extension phase. These $3\kappa$ computations of $G$ can actually be done during the precomputation phase as they are independent of the input elements. The main difference between KOS15 and ALSZ13 lies in steps $9-11$, the check correlation phase. In this phase, both parties utilize a random oracle functionality $\mathcal{F}_{\text{Rand}}(\mathbb{F}^{m'}_{2^\kappa})$ to obtain equal random values. Bob then performs twice $m'$ $\kappa$-bit sums, $m'$ $\kappa$-bit multiplications and sends $2\kappa$ bits ($x$ and $t$) to Alice, who in turn performs $m'$ $\kappa$-bit sums and $m'$ $\kappa$-bit multiplications. For the purpose of simplicity, we assume that each $\kappa$-bit sum takes $\kappa$ bit operations, and multiplication takes $\kappa^{1.585}$, using the Karatsuba method for multiplication with $O(\kappa^{1.585})$ complexity and schoolbook addition with $O(\kappa)$ complexity.

Let us compare the binary operations between KOS15 and $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ as we did with the ALSZ13 protocol. Denote by $B_{\text{op}}^\text{KOS15}$ and $B_{\text{op}}^\text{BBCS}$ the number of binary operations executed by KOS15 and $\Pi^{\textbf{BBCS}}_{\textbf{O}}$, respectively. Again, without taking into account the execution of $3 m$ hash functions and assuming that $\kappa \sim l$, $B_{\text{op}}^\text{KOS15}$ is roughly given by,
\begin{eqnarray*}
\begin{split}
    B_{\text{op}}^\text{KOS15} &= 3m\kappa + 3ml + m\kappa \\
    &+ m\kappa + m \log m \\
    &+ 3(m + (\kappa + w))\kappa \\
    &+ 2(m + (\kappa + w))\kappa^{1.58}\\
    &= 11 m \kappa  + m\log m \\
    &+ 3\kappa^2 + 3w\kappa  \\
    &+ 2 m \kappa^{1.58} + 2 \kappa^{2.58} + 2w\kappa^{1.58}
\end{split}
\end{eqnarray*}
and $B_{\text{op}}^\text{BBCS} = 8 m \kappa$. Therefore, KOS15 has more $B_{\text{op}}^\text{KOS15} - B_{\text{op}}^\text{BBCS}  \geq 5 m\kappa + m\log m$ binary operations than $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ transfer phase. 
%Now, since $m$ SHA-1 executions requires at least $480 m$ binary operations \cite{Santos2021, NISTSHA} and a common value for $\kappa$ is $\kappa = 128$ \cite{K15}, we have that $m$ SHA-1 executions requires at least $3 m \kappa$ binary operations. Adding $3 m \kappa$ to $4 m\kappa$, we have that KOS15 has at least $7 m\kappa$ more binary operations than HQOT transfer phase, which is almost twice as much binary operations as the quantum version ($\sim 88\%$). 
For this estimation, note that we are considering the lower bound $2 m \kappa$ instead of $2 m \kappa^{1.58}$ and we are not taking into account the implementation of the random oracle $\mathcal{F}_{\text{Rand}}(\mathbb{F}^{m'}_{2^\kappa})$, which would add an extra cost linear in the number of OT executions.

Regarding the communication complexity, the number of bits sent during both KOS15 and $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ is almost the same. KOS15 only adds $\kappa$ bits to the communication during the check correlation phase. However, since this overhead is independent of $m$ (number of OTs executed) its effect is amortized for big $m$.

\section{Conclusion}


The security and efficiency of OT implementations is crucial for secure computations, especially in the context of Yao's garbled circuit protocol. While classical OT protocols rely on asymmetric cryptographic primitives, which are known to be vulnerable to quantum attacks or have security based on conjectures, several works \cite{Lemus20, BCKM21, GLSV21, U10} have used the laws of physics to prove the security of BBCS-based QOT protocols against malicious adversaries with access to quantum computers. Additionally, using oblivious keys can separate the quantum technological burden from the execution of OT and enable efficient implementation.

In this chapter, we compared an optimized version ($\Pi^{\textbf{BBCS}}_{\textbf{O}}$) of the BBCS-based QOT protocol's transfer phase with the transfer phase of what is currently considered the fastest implementation of OT (ALSZ13). Our results showed that the transfer phase of $\Pi^{\textbf{BBCS}}_{\textbf{O}}$ has the potential to be faster than the ALSZ13 protocol while offering higher security, as it is secure in the malicious setting while ALSZ13 is only secure in the semi-honest model. Furthermore, our analysis revealed that the transfer phases of current maliciously secure implementations (ALSZ15 and KOS15) have a higher computation and communication complexity than $\Pi^{\textbf{BBCS}}_{\textbf{O}}$.

%\bibliography{bibforthesis}
%\bibliographystyle{unsrt}
%\end{document}
