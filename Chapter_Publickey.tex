%\documentclass[11pt]{report}
%\linespread{1.3} %1.3 for one and a half spacing, 1.6 for double
%\usepackage{amsmath, amsthm, amssymb, graphicx, caption, makeidx, cite, braket, url, color}
%%\usepackage[nohug,heads=vee]{diagrams}
%%\diagramstyle[labelstyle=\scriptstyle]
%%\graphicspath{{./Figures/}}
%\usepackage[margin=2.5cm]{geometry}
%%\title{Title}
%%\author{Chrysoula Vlachou}
%%\date{}
%\newtheorem{lemma}{Lemma}
%\newtheorem{theorem}{Theorem}
%\newtheorem{proposition}{Proposition}
%%\theoremstyle{definition}
%\newtheorem{definition}{Definition}
%\newtheorem{protocol}{Protocol}
%\newcommand{\N}{\mathbb N}
%\newcommand{\R}{\mathbb R}
%\newcommand{\C}{\mathbb C}
%\newcommand{\Hilb}{\mathcal H}
%\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
%\newcommand{\mmobh}{\textlatin{M\"ob}(\mathbb{H})}
%\newcommand{\areah}{\textlatin{area}_{\mathbb{H}}}
%\newcommand{\dth}{d_{\mathbb{H}}}
%\newcommand{\tdth}{$d_{\mathbb{H}}$ }
%\def\h{\mathbb H}
%\DeclareMathOperator{\Tr}{Tr}
%\def\I{\hat I}
%\def\ds{\displaystyle}
%\def\ppmod{\!\!\!\!\!\pmod}
%\newcommand{\walkop}{U_{\text{walk}}}
%
%\def\poly{poly}
%\def\span{span}
%\def\O{\textbf{\textit{O}}}
%\newcommand{\innerproduct}[2]{\langle #1 | #2 \rangle}
%\def\mobh{\textlatin{M\"ob}({\mathbb H})}
%\def\span{span}


%\begin{document}
\pagestyle{plain}

\begin{center}
\begin{Huge}
\textbf{Part I\\ \vspace{\baselineskip}Applications of Quantum Walks in Cryptography}\end{Huge}
\end{center}\
\newpage
\chapter{A public-key cryptographic system based on quantum walks}



In this chapter, we present a quantum public-key cryptographic system, in which the public keys are states generated by means of a QW, while the secret key consists of: (i) the QW operator, (ii) the number of steps that the walk is performed and (iii) the starting position and coin of the QW.   
In the next section we present the protocol and prove its correctness, while in the following Sections~\ref{sec:secpk} and~\ref{sec:effpk}, we prove its security and efficiency. Finally, in the last section we summarise our results and point out some possible directions for future work.

\vfill

\begin{center}
 *The work presented in this chapter corresponds to the work published in~\cite{vla:rod:mat:pau:sou:15}.
\end{center}

\newpage

\section{Public-key encryption based on discrete-time quantum walks}
\label{sec:pkscheme}
For our public-key cryptographic system we will consider DTQWs on a circle, as presented in Section~1.4 of the introductory Chapter 1. To generate the public key, we use a discrete number of possible walks $\hat{U}_k = \hat{S} [ \hat{I} \otimes \hat{U}_c (\theta_k, \xi_k, \zeta_k)]$, with $\theta_k = \xi_k = \zeta_k = k \frac{2\pi}{d}$, $k~\in~\mathcal I=\{1,2,\ldots,d\}$ and $d \in \mathbb N$, given by the standard shift and coin operations $\hat{U}_c (\theta_k, \xi_k, \zeta_k)$, presented in Section~1.4.


\begin{protocol}[Public-key encryption scheme]\
\label{prot:pk} 
\begin{description}
\item[\hspace{3mm}{\em Inputs for the protocol}]\
	\begin{itemize}
		\item Message to transfer: 

			$m\in \{0, \dots, 2^n-1 \}$, i.e., a message of at most $n$ bits;

		\item Secret key $SK = (\hat U_k, t, l, s)$ where:

			$\hat{U}_k$ with $k~\in~\mathcal I=\{1,2,\ldots,d\}$, 
			$t~\in~\mathcal{T} = \{ t_0, \dots, t_{max} \} \subset \mathbb{N}$, 
			$l \in \{ 0, \dots, 2^n-~1\} $ and $s \in\{ L,R\}$.
			
	\end{itemize}

\item[\hspace{3mm} {\em Public-key generation}]\
	\begin{itemize}
	\item $A$ chooses uniformly at random $l \in \{0, \dots ,2^n-1 \} $ and 
	$s \in\{ L,R\}$, and generates the initial state $\Ket{l}\Ket{s}$;
	
	\item Then she chooses, also uniformly at random, the walk 
	$\hat{U}_k = \hat{S} (\hat{I}_p \otimes \hat U_{c})$ 
	and the number of steps $t\in\mathcal T$;   
	
	\item Finally, she generates the public key:
	\begin{equation}
	\Ket{\psi_{PK}} 	= \hat{U}_k^t\Ket{l}\Ket{s} 
				= \left[\hat{S} (\hat{I}_p \otimes \hat U_{c})\right]^t \Ket{l}\Ket{s}.
	\end{equation}
	\end{itemize}

\item[\hspace{3mm} {\em Message Encryption}]\
	\begin{itemize}
	
	\item $B$ obtains $A$'s public key $\Ket{\psi_{PK}}$;
	
	\item He encrypts $m$ by applying a spatial translation to obtain: 
		\begin{equation}
		\Ket{\psi(m)} = (\hat{T}_m\otimes \hat{I}_c) \Ket{\psi_{PK}};
		\end{equation} 
		
	\item $B$ sends $\Ket{\psi(m)}$ to $A$.
	\end{itemize}
	
	\item[\hspace{3mm} {\em Message Decryption}]\
	\begin{itemize}
	\item $A$ applies $\hat{U}_k^{-t}$ to the state $\Ket{\psi(m)}$;

	\item She performs the measurement 
	\begin{equation}
	\hat{M} = \sum_{i}\Ket{i} \Bra{i}\otimes \hat{I}_c
	\end{equation} 
	and obtains the result $m'$. The message sent by $B$ is $m= m' - l \pmod N$.
\end{itemize}
\end{description}
\end{protocol}


\subsection{Correctness of the protocol}

\begin{proposition}
The above protocol  is correct, that means that if $A$ and $B$ follow it, and no third party intervenes during its execution, at the end of the decryption phase $A$ recovers the message sent by $B$ with probability $1$.
\end{proposition}

\begin{proof}
The correctness of the protocol when both parties follow the prescribed steps is a direct consequence of the fact that the QW $\hat{U}_k^t$ commutes with any translation $\hat{T}_m$ (see the following Lemma 1). Thus, the state of the system before the final step of the decryption phase (measurement), is: 
\begin{eqnarray}
\Ket {\psi_f}	&=& \hat{U}_k^{-t}\Ket{\psi(m)} \nonumber\\
			&=& \hat{U}_k^{-t} (\hat{T}_m \otimes \hat{I}_c) \hat{U}_k^t \Ket{l}\Ket{s} \\
			&=& (\hat{T}_m \otimes \hat{I}_c) \Ket{l}\Ket{s} \nonumber\\
			&=& \Ket{l+m  \ppmod N}\Ket{s}.\nonumber
\end{eqnarray}

Hence, upon measuring $\hat{M}$ and obtaining $m' = l+m \!\!\pmod N$, the last modular operation performed in the last step of the {\em Message Decryption} reveals that the decrypted message is indeed $m$. 
\end{proof}


Below, we prove that $\hat{U}_k^t$ and $(\hat{T}_m \otimes \hat{I}_c)$ commute. 

\begin{lemma}
Let $N\geq 2^n$ where $n$ is a fixed integer. 
Let $\hat{U}_k^t$ be a QW from Protocol~\ref{prot:pk} and let $\hat{T}_m$ denote the translation operator for $m$ positions modulo $N$. Then $\hat{U}_k^t$ and $(\hat{T}_m\otimes \hat{I}_c)$ commute.
\end{lemma}

\begin{proof}
Notice that the action of any $\hat U_k$ used in Protocol~\ref{prot:pk} can be written as:
\begin{eqnarray}
\hat U_k\Ket{l}\Ket{s} = \alpha_{L(s)} \Ket{l-1} \Ket{L} +\alpha_{R(s)} \Ket{l+1} \Ket{R},
\end{eqnarray}
where $\Ket{L}$ and $\Ket{R}$ are the orthogonal coin states and 
$\alpha_{L/R(s)}$ is the probability amplitude to find the walker in position $l-1$ or $l+1$, depending on its spin.
Notice also that $\hat{T}_m$ is defined as:

\begin{eqnarray}
\hat{T}_m \Ket{l} = \Ket{l+m \ppmod N}.
\end{eqnarray}

Then, for any element of the form $\Ket{l}\Ket{s}$ we have:

\begin{eqnarray}
(\hat{T}_m\otimes \hat{I}_c) \hat{U}_k  \Ket{l}\Ket{s}
	&=&(\hat{T}_m\otimes \hat{I}_c) [ \alpha_{L(s)} \Ket{l-1} \Ket{L} + \alpha_{R(s)} \Ket{l+1}\Ket{R} ]\nonumber\\
	&=& \alpha_{L(s)} \Ket{l-1+ m  \ppmod N} \Ket{L}\\ && + \alpha_{R(s)} \Ket{l+1 + m  \ppmod N} \Ket{R}.\nonumber
\end{eqnarray}

On the other hand, we also have:

\begin{eqnarray}
	\hat{U}_k(\hat{T}_m\otimes \hat{I}_c) \Ket{l}\Ket{s}
		&=& \hat{U}_k \Ket{l + m  \ppmod N}\Ket{s}\nonumber\\
		&=& \alpha_{L(s)} \Ket{l-1+ m  \ppmod N} \Ket{L} \\ 
		& &+ \alpha_{R(s)} \Ket{l+1 + m  \ppmod N} \Ket{R}.\nonumber
\end{eqnarray}
\end{proof}
Observe that this lemma can be extended to more general shift operations, which allow for jumps across two or more positions, or even leave the position state unchanged, depending on the coin state. 


\section{Security of the protocol}
\label{sec:secpk}
The protocol consists of two phases. In the first, $A$ sends a public key $\Ket{\psi_{PK}}$ to $B$. In the second, upon encrypting the message $m$, $B$ sends back to $A$ the state $\Ket{\psi(m)}$. Therefore, one has to show the security of the secret key during the first phase and the security of the message during the second phase.

Our proof of security is based on Holevo's Theorem, that bounds the amount of classical information that an eavesdropper can retrieve from a given quantum mixed state by means of a POVM measurement.

Let us denote by $\hat{\rho}_{PK}$ the mixed state of the public key, as perceived by $E$, who does not know \textit{a priori} the secret key $SK$ chosen by $A$. 
Even if $E$ were to know $\hat U_k$ and $t$, $\hat{\rho}_{PK}$ is completely mixed:

\begin{eqnarray}
\hat{\rho}_{PK} 
	&=& \hat{U}_k^t\left[\frac{1}{2^{n+1}} \sum_{l = 0}^{2^n-1} \sum_{s\in\{ L,R\}} \Ket{l} \Bra{l} \otimes \Ket{s} \Bra{s}\right](\hat{U}_k^t)^{\dagger}\nonumber\\
	&=& \hat{U}_k^t \left(\frac{1}{2^{n+1}} \hat{I}_p \otimes \hat{I}_c\right) (\hat{U}_k^t)^{\dagger} %
	\\
	&=& \frac{1}{2^{n+1}} (\hat{I}_p \otimes \hat{I}_c)\hat{U}_k^t (\hat{U}_k^t)^{\dagger} \\
	&=& \frac{1}{2^{n+1}} \hat{I}_p \otimes \hat{I}_c\nonumber.
\end{eqnarray}
Assuming that $E$ performs a measurement on $\hat{\rho}_{PK}$, Holevo's Theorem implies that the mutual information $I(SK,E)$ between the secret key $SK$ and her inference is bounded from above by the Von Neumann entropy of this state:
\begin{eqnarray}
I(SK,E) \leq S(\hat{\rho}_{PK})=-\tr(\hat{\rho}_{PK} \log\hat{\rho}_{PK} )=n+1.
\end{eqnarray}


To conclude that the protocol is secure we have to show that the mutual information is very small compared to the Shannon entropy of the secret key.
Indeed, the Shannon entropy of the secret key depends on the probability to choose $\hat U_k, t, l$ and  $s$.
In the following we denote by $p_k$ the probability to choose $\hat{U}_k$ from the set $\left\{\hat{U}_k | k\in \mathcal I= \{ 1,2,\dots,d\} \right\}$, by $p_t$ the probability to run the walk for $t$ steps, with $t \in \mathcal T=\{ t_0, \dots, t_{max} \}$, and by $p_{l,s}$ the probability to choose $l$ from $\{0,1,\ldots,2^n-1\}$ and $s$ from $\{L,R\}$ in order to generate the initial state $\Ket{l}\ket s$.
Since these choices are random and independent, the probability of a certain secret key $SK$ is given by:
\begin{equation}
p_{SK}=p_k \; p_t \; p_{l,s}=\frac{1}{d\; |\mathcal T|\; 2^{n+1}},
\end{equation}
where $|\mathcal T|$ is the cardinality of $\mathcal T$.


The above probability distributions are uniform, so the Shannon entropy of the secret key is:
\begin{eqnarray}
H(p_{SK})&=&
	-\sum_{k\in \mathcal I}\sum_{t\in \mathcal T}\sum_{l=0}^{2^{n}-1} \sum_{s\in\{L,R\}} p_k \; p_t \; p_{l,s}\log_2(p_k \; p_t \; p_{l,s})\nonumber\\[2mm]
	&=& \log_2(d \; |\mathcal T| \; 2^{n+1})\nonumber \\[2mm]
	&=& \log_2(d \; |\mathcal T| ) + n + 1.
\end{eqnarray}

Thus, we have:
\begin{equation}
I(SK,E)\leq S(\hat{\rho}_{PK})<H(p_{SK}),
\end{equation}
since $\log_2(d\; |\mathcal T|) >> 1$. 
With the appropriate choice of $|\mathcal T|$ and $d$, e.g.,  $|\mathcal T|, \log d \approx \poly(n)$, for sufficiently large $n$, the Shannon entropy of the secret  key has a polynomial overhead over the von Neumann entropy of the public key as seen by $E$,  \begin{equation}H(p_{SK}) - S(\hat{\rho}_{PK}) = \log_2(d \; |\mathcal T| ) \approx \poly(n).
\end{equation}
This way, upon obtaining the maximal possible information about the secret key, given by $S(\hat{\rho}_{PK})$, $E$'s uncertainty (in the number of bits) of the $SK$ is still polynomial in $n$, i.e., the number of keys consistent with the information she has is exponential in $n$. We note that the choice of $d \approx \exp(n)$ 
 
secures the secrecy of the encrypted message, while $|\mathcal T|  \approx \poly(n)$ was chosen to maintain the protocol's efficiency, discussed in the next section.

Notice that $d$ could be exponential on $n$, since in the protocol we only need to provide information to specify the walk (in fact, $\log(d)$ bits). However, in order for the protocol to be efficient as we discuss in the next section, $|\mathcal T|$ must be polynomial on $n$.


For the rest of this section we will discuss the security of the message $m$ during the second phase of the protocol, when $B$ sends the encrypted message $\Ket{\psi(m)} = (\hat{T}_m\otimes \hat{I}_c) \Ket{\psi_{PK}}$ to $A$. Without knowing the secret key, the state perceived by $E$ is still a complete mixture: 

\begin{eqnarray}
\hat{\rho}_E 
	&=&  (\hat{T}_{m}\otimes \hat{I}_c) \left(\frac{1}{2^{n+1}}  \hat{I}_p \otimes \hat{I}_c\right) (\hat {T}_m\otimes \hat{I}_c)^{\dagger}=\nonumber\\	
	&=&  \frac{1}{2^{n+1}}(\hat {T}_m\otimes \hat{I}_c) (\hat{T}_m\otimes\hat{I}_c)^{\dagger}(\hat{I}_p \otimes \hat {I}_c) = \frac{1}{2^{n+1}}\hat{I}_p \otimes \hat{I}_c.
\end{eqnarray}

The most that $E$ can learn is the very quantum state $\Ket{\psi(m)}$ (although, as proven above, even that is impossible, unless with negligible probability). Nevertheless, without knowing the secret key, this information is not enough for $E$ to infer the message encrypted by $B$. This is a simple consequence of the fact that for each allowed encryption state, there exists a suitably chosen secret key that can decrypt {\em any} message $m$. Indeed, a state $\Ket{\psi(m)}$ that for the secret key $SK = (\hat U_k, t, l)$ corresponds to the message $m$, for the secret key $SK' = (\hat U_k, t, l - \Delta l)$ corresponds to the message $m + \Delta l$ (below, the subscripts $SK$ and $SK'$ explicitly denote the secret key used to encrypt the corresponding messages $m$ and $m + \Delta l$, respectively):
\begin{eqnarray}
\Ket{\psi(m)}_{SK} 	& = & (\hat{T}_m\otimes \hat{I}_c) \Ket{\psi_{PK}}
=  (\hat{T}_{m}\otimes \hat{I}_c) \hat{U}_k^t  \Ket{l}\Ket{s} \nonumber \\
			& = & (\hat{T}_{m}\otimes \hat{I}_c) \hat{U}_k^t  (\hat{T}_{\Delta l}\otimes \hat{I}_c)\Ket{l - \Delta l}\Ket{s}\nonumber \\
			& = & (\hat{T}_{m}\otimes \hat{I}_c) (\hat{T}_{\Delta l}\otimes \hat{I}_c) \hat{U}_k^t  \Ket{l - \Delta l}\Ket{s}\nonumber \\
			& = & (\hat{T}_{m + \Delta l}\otimes \hat{I}_c) \hat{U}_k^t  \Ket{l - \Delta l}\Ket{s} \nonumber \\
			& = & \Ket{\psi(m + \Delta l)}_{SK'}. \end{eqnarray}



\section{Efficiency of the protocol}
\label{sec:effpk}
In this section we show the efficiency of the proposed protocol, i.e. that the overall time $\tau$ required for its execution (public-key generation, message encryption and message decryption) scales polynomially with the length $n$ of the message. 

The public-key generation, as well as the message decryption are efficient procedures, since performing the respective QWs is efficient.
Indeed, denoting by $\Delta\tau_w$ the time required for a single step $\hat U$ of the walk, the full walk $\hat U^t$ is completed in time $\tau=t\cdot\Delta\tau_w$. In the previous section we took $t \approx \poly(n)$ for security purposes, a choice which is also adequate for the efficiency of the QW: the time required to perform the walk is polynomial in $n$.

In addition to this, for the overall protocol to be efficient, the message encryption, given by the translation operator  $\hat{T}_m$, has to be efficient as well. It might seem at first that the encryption of the message is not efficient, as it requires $\O(2^n)$ single-position translations, $\hat{T}_m=(\hat{T}_1)^m$. Below, we show that this is not necessarily a non-efficient procedure, i.e., various practical implementations of $\hat{T}_m$ are indeed efficient.

In case the system that performs the QW consists of $n+1$ qubits ($n$ carrying the position of the walker plus the coin one), such that the states of the computational basis encode different positions (see for example~\cite{rya:laf:boi;laf:05}), the translation operator $\hat{T}_m$ is nothing but the addition by $m$, which is an efficient operation in a quantum computer.
Alternatively, in those cases of physical realisations in which different position states $\ket i$ are given by distinct spatial positions (see for example implementations based on integrated photonics\cite{san:etal:12}), $B$ can simply relabel the positions on the device that carries the quantum state of the public key, i.e. $i \rightarrow i-m$, which is also efficient, as he can do it in parallel at the same time for all the position states.

\section{Conclusions}
\label{sec:conclusions}
We presented a quantum public-key cryptographic system based on QWs. Unlike a recent similar protocol~\cite{nik:08}, which uses single-qubit rotations to generate the public key, in our scheme the execution of a QW, in general, results in entangled quantum states as public keys, thus increasing the practical security (an eavesdropper has to, in general, perform more complex operations to extract information from entangled rather than from product states). Using Holevo's theorem, we proved the protocol's security. We also analysed the complexity of our public-key generation and message encryption/ decryption procedures and showed their efficiency, i.e., the complexity of our protocol scales polynomially with the size of the message.

In the next chapter, we will use QWs to design QKD protocols. However, we should mention here that the applications of QWs in cryptography are not yet exhausted. A relevant path of future research would be to design other kinds of security protocols based on QWs, such as oblivious transfer (along the lines of the protocol proposed in~\cite{pmat:npaunkovic:jrodr:asouto:14}) and commitment schemes, as well as privacy functionalities, like message authentication and quantum digital signatures.


%\bibliography{bibforthesis}
%\bibliographystyle{unsrt}
%
%\end{document}
