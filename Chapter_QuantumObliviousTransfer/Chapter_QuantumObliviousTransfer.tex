%\documentclass[11pt]{report}



%\begin{document}

\chapter{Quantum Oblivious Transfer}
%\addcontentsline{toc}{chapter}{Introduction}


In a recent survey on classical oblivious transfer (OT) \cite{YAVV22}, all the analysed protocols require some form of asymmetric cryptography. Indeed, in the classical setting, it is impossible to develop information-theoretic secure OT or even reduce it to one-way functions, requiring some public-key computational assumptions. As shown by Impaggliazzo and Rudich \cite{IR89}, one-way functions (symmetric cryptography) alone do not imply key agreement (asymmetric cryptography). Also, Gertner et al. \cite{GKMRV00} pointed out that since it is known that OT implies key agreement, this sets a separation between symmetric cryptography and OT, leading to the conclusion that OT cannot be generated alone by symmetric cryptography. Otherwise, one could use one-way functions to implement key agreement through the OT construction. This poses a threat to all classical OT protocols \cite{EGL85, NP01, CO15} that are based on mathematical assumptions provably broken by a quantum computer \cite{Sho95}. Besides the security problem, asymmetric cryptography tends to be computationally more complex than symmetric cryptography, creating a problem in terms of speed when a large number of OTs are required. The classical post-quantum approach, thrives to find protocols resistant against quantum computer attacks. However, these are still based on complexity problems and are not necessarily less computationally expensive, than the previously mentioned ones. 

In parallel to the classical post-quantum approach, the quantum cryptography community presented some OT protocols based on quantum technologies to tackle this security issue. Intriguingly enough, more than a decade before the first classical OT by Rabin (1981, \cite{Rabin81}) was published, Wiesner proposed a similar concept. However, at the time it was rejected for publication due to the lack of acceptance in the research community. The first published quantum OT (QOT) protocol, known as the BBCS (Bennett-Brassard-Cr{\'e}peau-Skubiszewska) protocol \cite{BBCS92} was only presented in 1992. Remarkably, there is a distinctive difference between classical and quantum OT from a security standpoint, as the latter is proved to be possible assuming only the existence of quantum-hard one-way functions \cite{GLSV21, BCKM21}. This means quantum OT requires weaker security assumptions than classical OT.

In this chapter, we review the particular topic of quantum OT. We mainly comment on several important OT protocols, their underlying security models and assumptions. To the best of our knowledge, there is no prior survey dedicated to quantum OT protocols alone. Usually, its analysis is integrated into more general surveys under the topic of ``quantum cryptography", leading to a less in-depth exposition of the topic. For reference, we provide some distinctive reviews on the general topic of quantum cryptography \cite{BC96, B05, M06, F10, B15, PAB+20, PR21, SH22}.

This chapter is divided as follows. We start by giving a brief overview of the impossibility results related to quantum OT. Then, we provide an exposition about some of the most well-known quantum OT protocols based on assumptions. Finally, we give a brief overview of OT protocols not covered throughout this thesis.

%********************************** %First Section  **************************************
\section{Impossibility results}

The beginning of the development of quantum OT (QOT) came hand in hand with the development of quantum bit commitment (QBC). In fact, the first proposed QOT protocol (BBCS \cite{BBCS92}) reduces QOT to QBC . This sets a distinctive difference between classical and quantum protocols. Although bit commitment (BC) can be reduced to oblivious transfer (OT) \cite{K88}, the reverse is not true using only classical communication \cite{S99}. Therefore, Yao's proof \cite{Y95} of BBCS protocol \cite{BBCS92} gives quantum communications the enhanced quality of having an equivalence between QOT and QBC - they can be reduced to each other - a relation that is not known in the classical realm.

At the time of the BBCS protocol, the quest for unconditionally secure QOT was based on the possibility of unconditional secure QBC. A year later, Brassard et al. presented a QBC protocol \cite{BCJL93} named after the authors, BCJL (Brassard-Cr√©peau-Jozsa-Langlois). However, this work presented a flawed proof of its unconditional security which was generally accepted for some time, until Mayers spotted an issue on it \cite{M96}. Just one year after, Lo and Chau \cite{LC97}, and Mayers \cite{M97} independently proved unconditional QBC to be impossible. Nevertheless, the existence of unconditionally secure QOT not based on QBC was still put as an open question \cite{BC96} even after the so-called no-go theorems \cite{LC97, M97}. However, Lo was able to prove directly that unconditionally secure QOT is also impossible \cite{L97}. He concluded this as a corollary of a more general result that states that secure two-party computations which allow only one of the parties to learn the result (one-side secure two-party computation) cannot be unconditionally secure. Lo's results triggered a line of research on the possibility of two-sided secure two-party computation (both parties are allowed to learn the result without having access to the other party's inputs), which was also proved by Colbeck to be impossible \cite{C07} and extended in subsequent works \cite{BCS12, SSS14, SJFHV13}. For a more in-depth review of the impossibility results presented by Lo, Chau and Mayers, we refer the interested reader to the following works \cite{BCMS97, S99}.

Although the impossibility results have been well accepted in the quantum cryptography community, there was some criticism regarding the generality of the results \cite{Y00, Y02, Y04, C03}. This line of research reflects the view put forward by Yuen \cite{Y00} in the first of these papers: ``Since there is no known characterization of all possible QBC protocols, logically there can really be no general impossibility proof, strong or not, even if it were indeed impossible to have an unconditionally secure QBC protocol.'' In parallel, subsequent analyses were carried out, reaffirming the general belief of impossibility \cite{B01, C05, Che07}. However, most of the discord has ended with Ariano et al. proof \cite{A07} in 2007, giving an impossibility proof covering all conceivable protocols based on classical and quantum information theory. Subsequent work digested Ariano et al. \cite{A07} work, trying to present more succinct proofs \cite{CAP10, CAPSW13, H13} and to translate it into categorical quantum mechanics language \cite{K12, SHW20, BK22}. 

Facing these impossibility results, the quantum cryptography community followed two main paths:

\begin{enumerate}
    \item Develop OT protocols under some assumptions. These could be based on limiting the technological power of the adversary (e.g. noisy-storage model, relativistic protocols, isolated-qubit model) or assuming the security of additional functionalities (e.g. bit commitment).
    \item Develop OT protocols with a relaxed security definition. These allow the adversary to extract, with a given probability, some information (partial or total) about the honest party input/output. This approach leads to the concepts of weak OT  and weak private database query.
\end{enumerate}

In the next section, we explore protocols that produce a special primitive called \textit{oblivious keys} as an intermediate step.


%********************************** %Second Section  **************************************
\section{BBCS-based protocols}

In this section, we explore protocols that circumvent the no-go theorems \cite{LC97, M97} through assumptions. Some of the presented solutions are based on one-way functions, which are believed to be quantum-hard \cite{BCKM21, GLSV21,A02}, and others rely on technological or physical limitations of the adversaries \cite{DFSS05, WST08, KWW12, L14, Pit16, Ken11}. The latter are qualitatively different from complexity-based assumptions on which post-quantum protocols rely. Also, all these assumptions have the important property that they only have to hold during the execution of the protocol for its security to be preserved. In other words, even if the assumptions lose their validity at some later point in time, the security of the protocol is not compromised. This property is commonly known as \textit{everlasting} security \cite{U18}. Everlasting security is also a major distinctive feature of quantum protocols when compared with classical cryptographic approaches.

We start by presenting the first QOT protocol. Then, we see how this leads to the development of two assumption models: $\mathcal{F}_{\text{COM}}-$hybrid model and the limited-quantum-storage model. 

\subsection{BBCS protocol}\label{sec:BBCS}

In 1983, Wiesner came up with the idea of \textit{quantum conjugate coding} \cite{W83}. This technique is the main building block of many important quantum cryptographic protocols \cite{BB84, BBBW83, DFSS14}, including quantum oblivious transfer \cite{BBCS92}. It also goes under the name of \textit{quantum multiplexing} \cite{BBBW83}, \textit{quantum coding} \cite{BBB14} or \textit{BB84 coding} \cite{S99}. In quantum conjugate coding we encode classical information in two conjugate (non-orthogonal) bases. This allows us to have the distinctive property that measuring on one basis destroys the encoded information on the corresponding conjugate basis. So, when bit $0$ and $1$ are encoded by these two bases, no measurement is able to perfectly distinguish the states. We will be using the following bases in the two-dimensional Hilbert space $\mathcal{H}_2$:

\begin{itemize}
    \item Computational basis: $+ := \left\{\ket{0}_{+}, \ket{1}_{+}\right\}$;
    \item Hadamard basis: $\times := \left\{\ket{0}_{\times}, \ket{1}_{\times}\right\} = \left\{\frac{1}{\sqrt{2}}\big( \ket{0}_{+} + \ket{1}_{+} \big), \frac{1}{\sqrt{2}}\big( \ket{0}_{+} - \ket{1}_{+} \big) \right\}$.
\end{itemize}

\noindent\textbf{Protocol \cite{BBCS92}.} The first proposal of a quantum oblivious transfer protocol (BBCS protocol) is presented in Figure~\ref{fig:BBCS} and builds on top of the quantum conjugate coding technique. Alice starts by using this coding to generate a set of qubits that are subsequently randomly measured by Bob. These two steps make up the first phase of the BB84 QKD protocol. For this reason, it is called the \textit{BB84 phase}. Next, with the output bits obtained by Bob and the random elements generated by Alice, both parties are ready to share a special type of key, known as \textit{oblivious key}. This is achieved when Alice reveals her bases $\bm{\theta}^{\mathsf{A}}$ to Bob. Using the oblivious key as a resource, Alice can then obliviously send one of the messages $m_0, m_1$ to Bob, ensuring that he is only able to know one of the messages. This is achieved using a two-universal family of hash functions $\mathcal{F}$ from $\{0,1\}^{n/2}$ to $\{0,1\}^{l}$. Recall, we use the notation $s\leftarrow_{\$}S$ to describe a situation where an element $s$ is drawn uniformly at random from the set $S$.

\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{$\Pi^{\textbf{BBCS}}$ \textbf{protocol}}
            
            \
            
            \textbf{Parameters:} $n$, security parameter; $\mathcal{F}$ two-universal family of hash functions.
            
            \textbf{Alices's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
            
            \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
            
            \
            
            \textit{BB84 phase}:
            \begin{enumerate}
                \item Alice generates random bits $\bm{x}^{\mathsf{A}}\leftarrow_{\$}\{0,1\}^n$ and random bases $\bm{\theta}^{\mathsf{A}}\leftarrow_{\$}$~$\{+,\times\}^n$. Sends the state $\ket{\bm{x}^{\mathsf{A}}}_{\bm{\theta}^{\mathsf{A}}}$ to Bob.
                \item Bob randomly chooses bases $\bm{\theta}^{\mathsf{B}}\leftarrow_{\$}$~$\{+,\times\}^n$ to measure the received qubits. We denote by $\bm{x}^{\mathsf{B}}$ his output bits.
            \end{enumerate}
            
            \
            
            \textit{Oblivious key phase}:
            \begin{enumerate}
            \setcounter{enumi}{2}
                \item Alice reveals to Bob the bases $\bm{\theta}^{\mathsf{A}}$ used during the \textit{BB84 phase} and sets his oblivious key to $\mathsf{ok}^{\mathsf{A}}:=\bm{x}^{\mathsf{A}}$.
                \item Bob computes $\mathsf{e}^\mathsf{B} = \bm{\theta}^{\mathsf{B}} \oplus \bm{\theta}^{\mathsf{A}}$ and sets $\mathsf{ok}^{\mathsf{B}}:=\bm{x}^{\mathsf{B}}$.
            \end{enumerate}
            
            \
            
            \textit{Transfer phase}:
            \begin{enumerate}
            \setcounter{enumi}{4}
                \item Bob defines $I_0 = \{ i : \mathsf{e}^{\mathsf{B}}_i = 0 \}$ and $I_1 = \{ i : \mathsf{e}^{\mathsf{B}}_i = 1 \}$ and sends the set $I_b$ to Alice.
                \item Alice picks two uniformly random hash functions $f_0, f_1 \in \mathcal{F}$, computes the pair of strings $(s_0, s_1)$ as $s_i = m_i \oplus f_i(\mathsf{ok}^{\mathsf{A}}_{I_{b\oplus i}})$ and sends the pairs $(f_0, f_1)$ and $(s_0, s_1)$ to Bob.
                \item Bob computes $m_b = s_b \oplus  f_i(\mathsf{ok}^{\mathsf{B}}_{I_0})$. 
            \end{enumerate}
            
            \
            
        \textbf{Alice's output:} $\bot$.
        
        \textbf{output:} $m_b$.
        
        \end{tcolorbox}
    \caption{BBCS OT protocol.}
    \label{fig:BBCS}
\end{figure}

\

\noindent\textbf{Oblivious keys.} The term \textit{oblivious key} was used for the first time by Fehr and Schaffner \cite{FS09} referring to a Random OT. However, under a subtle different concept, it was used by Jakobi et al. \cite{JSGBBWZ11} as a way to implement Private Database Queries (PDQ). In a recent work, Lemus et al. \cite{Lemus20} presented the concept of oblivious key applied to OT protocols. We can define it as follows.

\begin{definition}[Oblivious key]
An oblivious key shared between two parties, Alice and Bob, is a tuple $\mathsf{ok}:= \big( \mathsf{ok}^{\mathsf{A}}, (\mathsf{ok}^{\mathsf{B}}, \mathsf{e}^{\mathsf{B}}) \big)$ where $\mathsf{ok}^{\mathsf{A}}$ is Alice's key, $\mathsf{ok}^{\mathsf{B}}$ is Bob's key and $\mathsf{e}^{\mathsf{B}}$ is the Bob's signal string. $\mathsf{e}^{\mathsf{B}}$ indicates which indexes of $\mathsf{ok}^{\mathsf{A}}$ and $\mathsf{ok}^{\mathsf{B}}$ are correlated and which indexes are uncorrelated, i.e. $\mathsf{e}^{\mathsf{B}}_i = 0$ when the corresponding indexes are correlated and $\mathsf{e}^{\mathsf{B}}_i = 1$ when they are not.
\label{def:ok}
\end{definition}

Note that, for some index $i$, when two index elements $\mathsf{ok}^{\mathsf{A}}_i$ and $\mathsf{ok}^{\mathsf{B}}_i$ are correlated, $\mathsf{ok}^{\mathsf{A}}_i=\mathsf{ok}^{\mathsf{B}}_i$. However, when they are uncorrelated, they are drawn independently. This means that both index elements may either be equal or different. Consider the following $\mathsf{ok}=\left( 001101101101, \left( 000101001100, 101000110001 \right) \right)$ as an example. We can check it is a well strucured oblivious key:

\begin{equation*}
    \left.\begin{array}{cc}
      \mathsf{ok}^{\mathsf{A}} :& \tikzmarkin{a}\red{0}\,\,\,\, \tikzmarkin{b}\green{0}\,\,\,\, \tikzmarkin{c}\red{1}\,\,\,\, \tikzmarkin{d}\green{1}\,\,\,\, \tikzmarkin{e}\green{0}\,\,\,\, \tikzmarkin{f}\green{1}\,\,\,\, \tikzmarkin{g}\red{1}\,\,\,\, \tikzmarkin{h}\red{0}\,\,\,\, \tikzmarkin{i}\green{1}\,\,\,\, \tikzmarkin{j}\green{1}\,\,\,\, \tikzmarkin{k}\green{0}\,\,\,\, \tikzmarkin{l}\red{1}  \\
      \mathsf{ok}^{\mathsf{B}} :& \red{0}\,\,\,\, \green{0}\,\,\,\, \red{0}\,\,\,\, \green{1}\,\,\,\, \green{0}\,\,\,\, \green{1}\,\,\,\, \red{0}\,\,\,\, \red{0}\,\,\,\, \green{1}\,\,\,\, \green{1}\,\,\,\, \green{0}\,\,\,\, \red{0} \\
      \mathsf{e}^{\mathsf{B}} :& \red{1}\tikzmarkend{a}\,\,\,\, \green{0}\tikzmarkend{b}\,\,\,\, \red{1}\tikzmarkend{c}\,\,\,\, \green{0}\tikzmarkend{d}\,\,\,\, \green{0}\tikzmarkend{e}\,\,\,\, \green{0}\tikzmarkend{f}\,\,\,\, \red{1}\tikzmarkend{g}\,\,\,\, \red{1}\tikzmarkend{h}\,\,\,\, \green{0}\tikzmarkend{i}\,\,\,\, \green{0}\tikzmarkend{j}\,\,\,\, \green{0}\tikzmarkend{k}\,\,\,\, \red{1}\tikzmarkend{l}
    \end{array}\right\} \mathsf{ok}
\end{equation*}


As we will see in later chapters, oblivious keys can be used as a resource to produce OT instances. In fact, we can draw a comparison between standard encryption keys and oblivious keys. In the same way as standard keys are the resource that allows the encryption of a specific message, oblivious keys are the resource that enables the performance of OT with messages. In other words, encryption methods consume standard keys, while OT methods consume oblivious keys. Moreover, it is worth stressing that oblivious keys are independent of the sender's messages  $m_0, m_1$ and are not the same as random OT. In fact, as Alice does not know the groups of indexes $I_0$ and $I_1$ computed by Bob after the basis revelation, Alice does not have her messages fully defined. A similar concept was defined by K\"onig et al.  \cite{KWW12} under the name of \textit{weak string erasure}. 

\

\noindent\textbf{Security.} Regarding security, the BBCS protocol is unconditionally secure against dishonest Alice. Intuitively, this comes from the fact that Alice does not receive any information from Bob other than some set of indexes $I_0$. However, the BBCS protocol is insecure against dishonest Bob. In its original paper \cite{BBCS92}, the authors describe a memory attack that provides Bob complete knowledge on both messages $m_0$ and $m_1$ without being detected. This can be achieved by having the receiver delay his measurements in step 2 to some moment after step 3. This procedure is commonly called the memory attack as it requires quantum \textit{memory} to hold the states until step 3. The authors suggest that, for the protocol to be secure, the receiver has to be forced to measure the received states at step 2. In the following sections, we present two common approaches to tackle this issue. We may assume the existence of commitments or set physical assumptions that constrain Bob from delaying his measurement.


%\bibliography{bibforthesis}
%\bibliographystyle{unsrt}
%\end{document}