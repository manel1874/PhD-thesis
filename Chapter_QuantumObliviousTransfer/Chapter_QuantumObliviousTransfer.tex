%\documentclass[11pt]{report}



%\begin{document}

\chapter{Quantum oblivious transfer}
\label{chapter_QOT}
%\addcontentsline{toc}{chapter}{Introduction}


In a recent survey on classical oblivious transfer (OT) \cite{YAVV22}, all the analyzed protocols were found to require some form of asymmetric cryptography. In the classical setting, it is not possible to develop information-theoretic secure OT or reduce it to one-way functions, and therefore public-key computational assumptions are required. Impaggliazzo and Rudich \cite{IR89} demonstrated that one-way functions alone cannot imply key agreement, which is an example of asymmetric cryptography. Additionally, Gertner et al. \cite{GKMRV00} noted that since OT implies key agreement, this establishes a separation between symmetric cryptography and OT. This conclusion suggests that it is not possible to generate OT using only symmetric cryptography, as one could potentially use one-way functions to implement key agreement through the OT construction. This poses a threat to all classical OT protocols \cite{EGL85, NP01, CO15} that rely on mathematical assumptions that can be provably broken by a quantum computer \cite{Sho95}.

Aside from the security issue, asymmetric cryptography tends to be computationally more complex than symmetric cryptography, creating problems with speed when a large number of OTs are required. The classical post-quantum approach aims to find protocols that are resistant to quantum computer attacks, but these protocols are still based on computational complexity problems and are not necessarily less computationally expensive than the previously mentioned protocols.

In parallel to the classical post-quantum approach, the field of quantum cryptography has attempted to address this security issue by developing OT protocols based on quantum technologies. Interestingly, Wiesner proposed a similar concept more than a decade before Rabin's classical OT was published in 1981 \cite{Rabin81}. At the time, Wiesner's proposal was rejected for publication due to a lack of acceptance in the research community. However, the first published quantum OT (QOT) protocol, known as the BBCS (Bennett-Brassard-Cr{\'e}peau-Skubiszewska) protocol \cite{BBCS92}, was not presented until 1992. There is a key difference between classical and quantum OT from a security perspective: quantum OT has been proved to be possible under the assumption of only the existence of quantum-hard one-way functions \cite{GLSV21, BCKM21}, meaning it requires weaker security assumptions than classical OT.

In this chapter, we delve into the subject of quantum oblivious transfer (OT). Our focus is on several key OT protocols, their security models, and underlying assumptions. To the best of our knowledge, there is no existing survey that is solely dedicated to quantum OT protocols. Typically, these protocols are analyzed as part of broader surveys on ``quantum cryptography", resulting in a less in-depth examination of the topic. For further reference, we have included some comprehensive reviews on the broader subject of quantum cryptography in \cite{BC96, B05, M06, F10, B15, PAB+20, PR21, SH22}.

The structure of this chapter is as follows: first, we provide a brief overview of the impossibility results related to quantum OT. Then, we delve into the exposition of some of the most well-known quantum OT protocols that are based on assumptions. Finally, we offer a brief overview of OT protocols that are not covered in detail in this thesis.

%********************************** %First Section  **************************************
\section{Impossibility results}

The emergence of quantum oblivious transfer (QOT) was closely linked to the development of quantum bit commitment (QBC). In fact, the first proposed QOT protocol (BBCS \cite{BBCS92}) reduces QOT to QBC, which sets a clear distinction between classical and quantum protocols. While classical bit commitment (BC) can be reduced to classical oblivious transfer (OT) \cite{K88}, the reverse is not true using only classical communication \cite{S99}. As a result, Yao's proof \cite{Y95} of the BBCS protocol \cite{BBCS92} highlights an enhanced characteristic of quantum communications: the equivalence between QOT and QBC - they can be reduced to each other - a relationship that is not present in the classical realm.


At the time of the BBCS protocol, researchers aimed to achieve unconditionally secure quantum oblivious transfer (QOT). This was based on the potential for unconditionally secure quantum bit commitment (QBC). One year after the proposal of BBCS, Brassard et al. introduced the BCJL protocol \cite{BCJL93}. However, it was later discovered that the protocol had a flawed proof of its unconditional security \cite{M96}. This was followed by independent proof from Lo and Chau \cite{LC97} and Mayers \cite{M97} that unconditionally secure QBC is actually impossible. Despite this, the question of unconditionally secure QOT not based on QBC remained open \cite{BC96}, even after the no-go theorems \cite{LC97, M97}. Lo eventually proved that unconditionally secure QOT is also impossible \cite{L97}. This conclusion was drawn as a corollary of a more general result, which stated that secure two-party computations where only one party learns the result cannot be unconditionally secure. Lo's results sparked a line of research on the possibility of two-sided secure two-party computation, which was later proven impossible by Colbeck \cite{C07} and further extended in subsequent works \cite{BCS12, SSS14, SJFHV13}. For further reading on the impossibility results presented by Lo, Chau and Mayers, the reader can refer to the works \cite{BCMS97, S99}.

Although the impossibility results in quantum cryptography have been widely accepted, some criticism has been raised regarding their generality \cite{Y00, Y02, Y04, C03}. Yuen \cite{Y00} argues that since there is no known characterization of all possible QBC protocols, it is logically impossible to have a general impossibility proof. Nevertheless, subsequent analyses \cite{B01, C05, Che07} have confirmed the general belief of the impossibility of unconditionally secure QBC. The criticism was finally put to rest with the proof by Ariano et al. \cite{A07} in 2007, which covered all conceivable protocols based on classical and quantum information theory. Subsequent works have tried to simplify the proof \cite{CAP10, CAPSW13, H13} and translate it into categorical quantum mechanics language \cite{K12, SHW20, BK22}.

In response to these impossibility results, the community has taken two main approaches:

\begin{enumerate}
    \item Development of OT protocols under certain assumptions, such as limiting adversary's technology (e.g. noisy-storage model, relativistic protocols, isolated-qubit model) or assuming the security of additional functionalities (e.g. bit commitment);
    \item Development of OT protocols with a relaxed security definition, where the adversary is allowed to extract some information about the honest party's input/output with a given probability. This approach gives rise to the concepts of weak OT and weak private database query.
\end{enumerate}

The next section will examine OT protocols that generate a special primitive known as \textit{oblivious keys} as an intermediate step.



%********************************** %Second Section  **************************************
\section{BBCS-based protocols}

This section investigates protocols that overcome the no-go theorems \cite{LC97, M97} through certain assumptions. These protocols are either based on one-way functions, considered to be quantum-hard \cite{BCKM21, GLSV21, A02}, or on the adversary's technological or physical limitations \cite{DFSS05, WST08, KWW12, L14, Pit16, Ken11}. The latter differs qualitatively from the complexity-based assumptions that post-quantum protocols rely on. Moreover, the security of these protocols is only dependent on the validity of the assumptions during the protocol execution and remains intact even if the assumptions are no longer valid later on. This property, known as \textit{everlasting} security \cite{U18}, is a defining feature of quantum protocols compared to classical cryptography.

We begin by introducing the first quantum oblivious transfer (QOT) protocol and then examine how it led to the development of two assumption models: $\mathcal{F}_{\text{COM}}-$hybrid and the limited-quantum-storage models.

\subsection{BBCS protocol}\label{sec:BBCS}

The concept of ``quantum conjugate coding" was introduced by Wiesner in 1983 \cite{W83}. It's a key element in many quantum cryptographic protocols, including quantum oblivious transfer \cite{BBCS92}. The technique is also known as ``quantum multiplexing" \cite{BBBW83}, ``quantum coding" \cite{BBB14}, and ``BB84 coding" \cite{S99}. It involves encoding classical information in two non-orthogonal (conjugate) bases, leading to a property where measuring in one basis erases information encoded in the other. So, when bit $0$ and $1$ are encoded by these two bases, no measurement is able to perfectly distinguish the states. We will be using the following bases in the two-dimensional Hilbert space $\mathcal{H}_2$:

\begin{itemize}
    \item Computational basis: $+ := \left\{\ket{0}_{+}, \ket{1}_{+}\right\}$;
    \item Hadamard basis: $\times := \left\{\ket{0}_{\times}, \ket{1}_{\times}\right\} = \left\{\frac{1}{\sqrt{2}}\big( \ket{0}_{+} + \ket{1}_{+} \big), \frac{1}{\sqrt{2}}\big( \ket{0}_{+} - \ket{1}_{+} \big) \right\}$.
\end{itemize}

Throughout this chapter, we simplify the notation by associating the basis set $\{+,\times\}$ with the binary set $\{0,1\}$: $+$ is associated with $0$ and $\times$ with $1$. This allows us to easily compare strings of bases between parties, i.e. the XOR operation ($\oplus$) between two vectors $\bm{\theta}^{\mathsf{A}}, \bm{\theta}^{\mathsf{B}} \in\{+,\times\}^n$ is defined as the XOR operation between the corresponding binary vectors $\bm{\theta}^{\mathsf{A}}, \bm{\theta}^{\mathsf{B}} \in\{0,1\}^n$.

\

\noindent\textbf{Protocol \cite{BBCS92}.} The first proposal for a quantum oblivious transfer protocol, known as Bennett-Brassard-Crépeau-Skubiszewska (BBCS), is shown in Figure~\ref{fig:BBCS}. It utilizes the quantum conjugate coding technique. The first phase of the BBCS QOT protocol, referred to as the \textit{BB84 phase}, consists of Alice encoding a set of qubits that are randomly measured by Bob. The parties then use Bob's output bits and Alice's random elements to generate a special type of key, known as \textit{oblivious key}. Alice reveals her bases $\bm{\theta}^{\mathsf{A}}$ to Bob to achieve this. Using the oblivious key as a resource and a two-universal family of hash functions $\mathfrak{F}$, Alice can then obliviously send one of the messages $m_0, m_1$ to Bob, ensuring he is only able to know one of the messages. Recall, we use the notation $s\leftarrow_{\$}S$ to describe a situation where an element $s$ is drawn uniformly at random from the set $S$.

\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{$\Pi^{\textbf{BBCS}}$ \textbf{protocol}}
            
            \
            
            \textbf{Parameters:} $n$, security parameter; two-universal family of hash functions $\mathfrak{F}$ from $\{0,1\}^{n/2}$ to $\{0,1\}^{l}$.
            
            \textbf{Alice's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
            
            \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
            
            \
            
            \textit{BB84 phase}:
            \begin{enumerate}
                \item Alice generates random bits $\bm{x}^{\mathsf{A}}\leftarrow_{\$}\{0,1\}^n$ and random bases $\bm{\theta}^{\mathsf{A}}\leftarrow_{\$}$~$\{+,\times\}^n$. Sends the state $\ket{\bm{x}^{\mathsf{A}}}_{\bm{\theta}^{\mathsf{A}}}$ to Bob.
                \item Bob randomly chooses bases $\bm{\theta}^{\mathsf{B}}\leftarrow_{\$}$~$\{+,\times\}^n$ to measure the received qubits. We denote by $\bm{x}^{\mathsf{B}}$ his output bits.
            \end{enumerate}
            
            \
            
            \textit{Oblivious key phase}:
            \begin{enumerate}
            \setcounter{enumi}{2}
                \item Alice reveals to Bob the bases $\bm{\theta}^{\mathsf{A}}$ used during the \textit{BB84 phase} and sets his oblivious key to $\mathsf{ok}^{\mathsf{A}}:=\bm{x}^{\mathsf{A}}$.
                \item Bob computes $\mathsf{e}^\mathsf{B} = \bm{\theta}^{\mathsf{B}} \oplus \bm{\theta}^{\mathsf{A}}$ and sets $\mathsf{ok}^{\mathsf{B}}:=\bm{x}^{\mathsf{B}}$.
            \end{enumerate}
            
            \
            
            \textit{Transfer phase}:
            \begin{enumerate}
            \setcounter{enumi}{4}
                \item Bob defines $I_0 = \{ i : \mathsf{e}^{\mathsf{B}}_i = 0 \}$ and $I_1 = \{ i : \mathsf{e}^{\mathsf{B}}_i = 1 \}$ and sends the $(I_b, I_{b\oplus 1})$ to Alice.
                \item Alice picks two uniformly random hash functions $f_0, f_1 \in \mathfrak{F}$, computes the pair of strings $(s_0, s_1)$ as $s_i = m_i \oplus f_i(\mathsf{ok}^{\mathsf{A}}_{I_{b\oplus i}})$ and sends the pairs $(f_0, f_1)$ and $(s_0, s_1)$ to Bob.
                \item Bob computes $m_b = s_b \oplus  f_i(\mathsf{ok}^{\mathsf{B}}_{I_0})$. 
            \end{enumerate}
            
            \
            
        \textbf{Alice's output:} $\bot$.
        
        \textbf{Bob's output:} $m_b$.
        
        \end{tcolorbox}
    \caption{BBCS OT protocol.}
    \label{fig:BBCS}
\end{figure}

\

\noindent\textbf{Oblivious keys.}  The term ``oblivious key" was first used by Fehr and Schaffner \cite{FS09} in reference to random OT. The notion was refined by Jakobi et al. \cite{JSGBBWZ11} for implementing private database queries (PDQ). In the BBCS protocol, oblivious keys are used as a resource to perform OT. Like standard encryption keys, they enable the performance of OT. In other words, encryption methods consume standard keys and OT methods consume oblivious keys. The concept of oblivious keys applied to OT protocols was recently presented by Lemus et al. \cite{Lemus20}. We can define it as follows.

\begin{definition}[Oblivious key]
An oblivious key shared between two parties, Alice and Bob, is a tuple $\mathsf{ok}:= \big( \mathsf{ok}^{\mathsf{A}}, (\mathsf{ok}^{\mathsf{B}}, \mathsf{e}^{\mathsf{B}}) \big)$ where $\mathsf{ok}^{\mathsf{A}}$ is Alice's key, $\mathsf{ok}^{\mathsf{B}}$ is Bob's key and $\mathsf{e}^{\mathsf{B}}$ is Bob's signal string. $\mathsf{e}^{\mathsf{B}}$ indicates which indexes of $\mathsf{ok}^{\mathsf{A}}$ and $\mathsf{ok}^{\mathsf{B}}$ are correlated and which indexes are uncorrelated, i.e. $\mathsf{e}^{\mathsf{B}}_i = 0$ when the corresponding indexes are correlated and $\mathsf{e}^{\mathsf{B}}_i = 1$ when they are not.
\label{def:ok}
\end{definition}

Note that, for some index $i$, when two index elements $\mathsf{ok}^{\mathsf{A}}_i$ and $\mathsf{ok}^{\mathsf{B}}_i$ are correlated, $\mathsf{ok}^{\mathsf{A}}_i=\mathsf{ok}^{\mathsf{B}}_i$. However, when they are uncorrelated, they are drawn independently. This means that both index elements may either be equal or different. Consider the following oblivious key $\mathsf{ok}=\left( 001101101101, \left( 000101001100, 101000110001 \right) \right)$ as an example. We can check it is a well-structured oblivious key:

\begin{equation*}
    \left.\begin{array}{cc}
      \mathsf{ok}^{\mathsf{A}} :& \tikzmarkin{a}\red{0}\,\,\,\, \tikzmarkin{b}\green{0}\,\,\,\, \tikzmarkin{c}\red{1}\,\,\,\, \tikzmarkin{d}\green{1}\,\,\,\, \tikzmarkin{e}\green{0}\,\,\,\, \tikzmarkin{f}\green{1}\,\,\,\, \tikzmarkin{g}\red{1}\,\,\,\, \tikzmarkin{h}\red{0}\,\,\,\, \tikzmarkin{i}\green{1}\,\,\,\, \tikzmarkin{j}\green{1}\,\,\,\, \tikzmarkin{k}\green{0}\,\,\,\, \tikzmarkin{l}\red{1}  \\
      \mathsf{ok}^{\mathsf{B}} :& \red{0}\,\,\,\, \green{0}\,\,\,\, \red{0}\,\,\,\, \green{1}\,\,\,\, \green{0}\,\,\,\, \green{1}\,\,\,\, \red{0}\,\,\,\, \red{0}\,\,\,\, \green{1}\,\,\,\, \green{1}\,\,\,\, \green{0}\,\,\,\, \red{0} \\
      \mathsf{e}^{\mathsf{B}} :& \red{1}\tikzmarkend{a}\,\,\,\, \green{0}\tikzmarkend{b}\,\,\,\, \red{1}\tikzmarkend{c}\,\,\,\, \green{0}\tikzmarkend{d}\,\,\,\, \green{0}\tikzmarkend{e}\,\,\,\, \green{0}\tikzmarkend{f}\,\,\,\, \red{1}\tikzmarkend{g}\,\,\,\, \red{1}\tikzmarkend{h}\,\,\,\, \green{0}\tikzmarkend{i}\,\,\,\, \green{0}\tikzmarkend{j}\,\,\,\, \green{0}\tikzmarkend{k}\,\,\,\, \red{1}\tikzmarkend{l}
    \end{array}\right\} \mathsf{ok}
\end{equation*}

It is worth stressing that oblivious keys are independent of the sender's messages  $m_0, m_1$ and are not the same as random OT. In fact, as Alice does not know the groups of indexes $I_0$ and $I_1$ computed by Bob after the basis revelation, Alice does not have her messages fully defined. A similar concept was defined by K\"onig et al.  \cite{KWW12} under the name of \textit{weak string erasure}. 

\

\noindent\textbf{Security.} Regarding security, the BBCS protocol provides unconditional security against dishonest Alice, as she only receives some set of indexes $I_0$ from Bob. However, it is insecure against dishonest Bob, who can carry out a memory attack and obtain complete knowledge of both messages $m_0$ and $m_1$ undetected \cite{BBCS92}. In the memory attack, Bob delays his measurements in step 2 until after step 3. This requires quantum memory, which is why it's called the memory attack. To mitigate this issue, the authors suggest forcing Bob to measure the received states at step 2. In subsequent sections, two common approaches to tackle this security flaw are presented: either by assuming the existence of commitments or by setting physical constraints that prevent Bob from delaying his measurements.


\subsection{BBCS in the $\mathcal{F}_{\textbf{COM}}-$hybrid model}\label{BBCS-com-hybrid}

As previously discussed, the BBCS protocol needs Bob to measure his qubits in step 2 for security. A solution to this issue, as proposed in \cite{BBCS92}, is the use of a commitment scheme. This approach results in a $\mathcal{F}_{\textbf{COM}}$-hybrid model, where $\mathcal{F}_{\textbf{COM}}$ refers to any commitment scheme (including ideal functionalities)\footnote{The notation $\mathcal{F}_{\textbf{COM}}$ is commonly used for ideal functionalities. However, for simplicity, we use $\mathcal{F}_{\textbf{COM}}$ to refer to any commitment scheme (including the ideal commitment functionality).}. 


\begin{figure}[h!]
\centering
\begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
                        
    \centerline{$\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ \textbf{protocol}}
            
    \
    
    \textbf{Parameters:} $n$, security parameter; $\mathfrak{F}$ two-universal family of hash functions.
    
    \textbf{Alice's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
    
    \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
    
    \
    
    \textit{BB84 phase:} \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    
    
    \
    
    \textit{Cut and choose phase}:
    \begin{enumerate}
    \setcounter{enumi}{2}
        \item Bob commits to the bases used and the measured bits, i.e. $\textbf{COM}\big(\bm{\theta}^\mathsf{B}, \bm{x}^\mathsf{B}\big)$, and sends to Alice. %using $\mathcal{F}_{\textbf{com}}$.
        \item Alice asks Bob to open a subset $T$ of commitments (e.g. $n/2$ elements) and receives $\{\theta_i^\mathsf{B}, x_i^\mathsf{B}\}_{i\in T}$.% from $\mathcal{F}_{\textbf{com}}$.
        \item In case any opening is not correct or $x_i^\mathsf{B} \neq x_i^\mathsf{A}$ for $\theta_i^\mathsf{B} = \theta_i^\mathsf{A}$, abort. Otherwise, proceed. 
    \end{enumerate}
    
    \
    
    \textit{Oblivious key phase:} \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
     
    \
     
    \textit{Transfer phase:} \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    
    \
    
\textbf{Alice's output:} $\bot$.

\textbf{Bob's output:} $m_b$.
    
\end{tcolorbox} 
    \caption{BBCS OT protocol in the $\mathcal{F}_{\textbf{COM}}-$hybrid model.}
    \label{fig:BBCS_COM}
\end{figure}

\noindent\textbf{Protocol.} The modified BBCS (Figure~\ref{fig:BBCS_COM}) adds a \textit{cut and choose} step using commitment scheme \textbf{COM}. In this step, Bob commits to the measurement bases and output bits from the \textit{BB84 phase}. Alice then selects a subset of qubits to verify, and Bob reveals the corresponding commitments. If no inconsistencies are found, the protocol continues. To ensure security, the size of the tested subset must be proportional to $n$ to guarantee Bob's measurement with high probability in $n$.

\

\noindent\textbf{Security.} The security of the modified BBCS protocol has been extensively studied in a long line of research \cite{CK88, BBCS92, MS94, Y95, M96b, CDMS04, FS09, DFLSS09, U10, BF10, GLSV21, BCKM21}. Early studies from the 1990s focused on analyzing security against limited adversaries who only made individual measurements \cite{MS94}. Later, Yao \cite{Y95} showed its security against general adversaries capable of fully coherent measurements. However, these initial works \cite{MS94, Y95, M96b} lacked a comprehensive security definition and relied on weak security measures like Collision Entropy and Mutual Information \cite{BCC+10, TR11}. In modern quantum cryptography, the protocol's security is established in quantum simulation-paradigm frameworks \cite{FS09, U10, DFLSS09, KWW12} using a simulator to show that a real execution is indistinguishable from an ideal, secure execution.


Desirable worst-case security measures for quantum oblivious transfer (QOT) were applied a decade later \cite{R06, DFRSS07}. These were based on the concept of \textit{min-entropy} \cite{BCC+10,TR11}, $H_{\text{min}}$, which, intuitively, reflects the maximum probability of an event to happen. To prove security against dishonest Bob, one is interested in measuring Bob's min-entropy on Alice's oblivious key $\mathsf{ok}^{\mathsf{A}}$ given any quantum side information $E$ he may have, i.e. $H_{\text{min}}(\mathsf{ok}^{\mathsf{A}} | E)$. Informally, for a bipartite classical-quantum state $\rho_{X E}$ the conditional min-entropy $H_{\text{min}}(X | E)$ is given by 

$$H_{\text{min}}(X | E)_{\rho_{X E}} := -\log P_{guess}(X|E),$$ 
where $P_{guess}(X|E)$ is the maximum probability the adversary can guess $x$ given all possible measurements. Damg{\aa}rd et al. \cite{DFLSS09} proved the stand-alone QOT security using this min-entropy measure and Fehr and Schaffner's \cite{FS09} quantum simulation-paradigm framework. Their argument to prove the security of the protocol against dishonest Bob can be summarized as follows. The cut and choose phase ensures that Bob's conditional min-entropy on the elements of $\mathsf{ok}^{\mathsf{A}}$ belonging to $I_{1}$ (indexes with uncorrelated elements) is lower-bounded by some value that is proportional to the security parameter, i.e. $H_{\text{min}}(\mathsf{ok}^{\mathsf{A}}_{I_{1}} | E) \geq n\lambda$ for some $\lambda > 0$. Note that this is equivalent to derive an upper bound on the guessing probability $P_{guess}(\mathsf{ok}^{\mathsf{A}}_{I_{1}}|E) \leq 2^{-n\lambda}$. Having deduced an expression for $\lambda$, they proceed by applying a random hash function $f$ from a two-universal family $\mathfrak{F}$, $f\leftarrow_{\$}\mathfrak{F}$. This final step ensures that $f(\mathsf{ok}^{\mathsf{A}}_{I_{1}})$ is statistically indistinguishable from uniform (privacy amplification theorem \cite{DFRSS07, RK05, R05}). The proof provided by Damg{\aa}rd et al. \cite{DFLSS09} was extended by Unruh \cite{U10} to the quantum Universal Composable (UC) model with ideal commitments. Now, a natural question arises: 

\

\centerline{\textit{Which commitment schemes can be used to render simulation-based security?}}

\

\noindent\textbf{Commitment scheme.} The work by Aaronson \cite{A02} provides non-constructive evidence ``that collision-resistant hashing might still be possible in a quantum setting'', which supports the use of commitment schemes based on quantum-hard one-way functions in $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$. It has been demonstrated that any one-way function, including quantum-hard ones, can be used to construct commitment schemes \cite{N91, HILL99, HR07}. However, using a commitment scheme based on a quantum-hard one-way function in $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ does not necessarily lead to a simulation-secure protocol. This is due to the difficulty or impossibility of simulation-based proof due to the nature of the commitment scheme. For more information, see \cite{GLSV21}.

For a commitment scheme to render simulation-based security, the simulator in its proof must have access to two intriguing properties: \textit{extractability} and \textit{equivocality}. Extractability allows the simulator to obtain the committed value from a malicious committer, while equivocality enables the simulator to modify the committed value later. Despite the counter-intuitive nature of using a commitment scheme where we can violate both security properties (hiding and biding properties), these properties are crucial for the scheme's security. The extractability is used to prove security against the dishonest sender, and equivocality is used to prove security against the dishonest receiver. There are proposals in the literature for commitment schemes $COM$ with these properties based on:

\begin{itemize}
    \item Quantum-hard one-way functions \cite{BCKM21, GLSV21};
    \item Common Reference String (CRS) model \cite{U10, CF01};
    \item Bounded-quantum-storage model \cite{U11};
    \item Quantum hardness of the Learning With Errors assumption \cite{DFLSS09}.
\end{itemize}

\

\noindent\textbf{Composability.} The integration of secure OT executions in secure multiparty protocols \cite{Y86} is critical to ensuring security, as improper integration could lead to security breaches. Although it seems intuitive to assume that a secure OT protocol can be integrated within more complex protocols, proving this is highly non-trivial as it is not clear a priori under which circumstances protocols can be composed \cite{MR09}. 

To address this challenge, the development of simulation-based security was introduced. However, simulation-based security alone is not sufficient for composability, as a composability framework is also necessary \cite{MR09}. Several composability frameworks have been proposed in the literature. Fehr and Schaffner \cite{FS09} proposed a framework for sequential composition of quantum protocols in a classical environment. Ben-Or and Mayers \cite{BM04} and Unruh \cite{U04, U10} extended the classical Universal Composability model \cite{C20} to a quantum setting, allowing concurrent composability. Maurer and Renner \cite{MR11} developed a more general composability framework that accommodates various models of computation, communication, and adversary behavior. Recently, Broadbent and Karvonen \cite{BK22} introduced an abstract model of composable security in terms of category theory. As far as we are aware, the composable security of the protocol $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ has been proven in the Fehr and Schaffner model \cite{FS09} by Damg{\aa}rd et al. \cite{DFLSS09} and in the quantum-UC model by Unruh \cite{U10}.



\subsection{BBCS in the limited-quantum-storage model}

In this section, we review protocols based on the limited-quantum-storage model. These protocols sidestep the no-go theorems by relying on reasonable assumptions about the storage capacities of both parties. There are two main approaches within this model. The first, the bounded-storage model, was introduced by Damg{\aa}rd et al. \cite{DFSS05}, who assumed that parties can store only a limited number of qubits. The second approach, the noisy-storage model, was initiated by Wehner et al. \cite{WST08}, who assumed that parties can store all qubits but they are unstable, i.e., they have imperfect, noisy storage that results in some decoherence. Both models force adversaries to use their quantum memories as both parties have to wait a predetermined time $(\Delta t)$ during the protocol.

\subsection{Bounded-quantum-storage model}

In the bounded-quantum-storage (BQS) model, we assume that adversaries can only store a fraction $0<\gamma<1$ of the transmitted qubits during the waiting time $\Delta t$. The adversary's storage capacity is limited to $q=n\gamma$ qubits. $\gamma$ is referred to as the storage rate.

\

\noindent\textbf{Protocol.} The protocol in the BQS model, $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$, is very similar to the BBCS protocol $\Pi^{\textbf{BBCS}}$ presented in Figure~\ref{fig:BBCS}. The difference is that both parties have to wait a predetermined time ($\Delta t$) after step 2. This protocol is presented in Figure~\ref{fig:BBCS_Bounded}.

\begin{figure}[h!]
\centering
\begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
    
    \centerline{$\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ \textbf{protocol}}
            
    \
    
    \textbf{Parameters:} $n$, security parameter; $\mathfrak{F}$  two-universal family of hash functions.
    
    \textbf{Alice's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
    
    \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
    
    \
    
    \textit{BB84 phase}: \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    
    
    \
    
    \textit{Waiting time phase}:
    \begin{enumerate}
    \setcounter{enumi}{2}
        \item Both parties wait time $\Delta t$.
    \end{enumerate}
    
    \
    
    \textit{Oblivious key phase}: \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
     
    \
     
    \textit{Transfer phase}: \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    
    \
    
\textbf{Alice's output:} $\bot$.

\textbf{Bob's output:} $m_b$.
    
\end{tcolorbox}
    \caption{BBCS OT protocol in the bounded-quantum-storage model.}
    \label{fig:BBCS_Bounded}
\end{figure}

\

\noindent\textbf{Security.} In this section, we focus on security against dishonest Bob in the BQS model. The justification for security against dishonest Alice follows from the original BBCS protocol, as detailed in Section~\ref{sec:BBCS}.

In the BQS model, the waiting time ($\Delta t$) prevents Bob from holding a significant portion of qubits until Alice reveals the bases choices $\bm{\theta}^{\mathsf{A}}$ used during the BB84 phase. This is because Bob is forced to measure a fraction of the qubits, causing him to lose information about Alice's bases $\bm{\theta}^{\mathsf{A}}$.

Damg{\aa}rd et al. \cite{DFRSS07} showed that, with overwhelming probability, the loss of information about Alice's oblivious key ($\mathsf{ok}^{\mathsf{A}}_{I_{1}}$) is described by the min-entropy lower bound:
$$H_{\text{min}}(\mathsf{ok}^{\mathsf{A}}_{I_{1}} | E) \geq \frac{1}{4}n - \gamma n - l - 1.$$
Similar to the $\mathcal{F}_{\textbf{COM}}-$hybrid model, the min-entropy value must be proportional to the security parameter $n$. To ensure security, an upper bound on the fraction of qubits that can be stored by the receiver must be set, i.e. $\gamma < \frac{1}{4}$.

K\"onig et al. \cite{KWW12} improved the upper bound to $\gamma < \frac{1}{2}$ and showed that the BQS model is a special case of the noisy-quantum-storage model. Further, Mandayam and Wehner \cite{MW11} presented a protocol that remains secure even when an adversary cannot store any fraction of the transmitted pulses, using higher-dimensional mutually unbiased bases. In this latter work, the storage rate $\gamma$ approaches 1 with increasing dimension.

\

\noindent\textbf{Composability.} The security of the protocol $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ was initially proven by Damg{\aa}rd et al. \cite{DFSS05, DFRSS07} under the stand-alone security model \cite{WW08}. However, this model does not guarantee the composability of the protocol. The sequential composability was later established by Wehner and Wullschleger \cite{WW08} in a simulation-based framework and by Fehr and Schaffner in a sequential composability framework.

Unruh \cite{U11} extended the quantum-UC framework and combined it with the BQS model to develop BQS-UC security. In this framework, composability is ensured while keeping track of the quantum memory bound used by the machines. Under this framework, Unruh follows a different approach as he does not use the protocol $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ (Figure~\ref{fig:BBCS_Bounded}). Unruh presented a BQS-UC secure commitment protocol and combined it with the $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ protocol to obtain a constant-round protocol that emulates any two-party functionality in a BQS-UC secure manner.


\subsection{Noisy-quantum-storage model}

The noisy-quantum-storage (NQS) model is a generalization of the bounded-quantum-storage (BQS) model. In the NQS model, the adversary is allowed to retain any fraction $\nu$ of the transmitted qubits, including the case where $\nu = 1$. However, the adversary's quantum memory is assumed to be noisy, meaning that qubits cannot be stored for a certain amount of time ($\Delta t$) without undergoing decoherence \cite{KWW12}. 

Mora formally, the decoherence of qubits in the noisy storage can be described by a completely positive trace-preserving (CPTP) map, also known as a channel, $\mathcal{C}: \mathcal{P}(\mathcal{H}_{\text{in}})\rightarrow \mathcal{P}(\mathcal{H}_{\text{out}})$. The Hilbert space of the stored qubits before and after the storage period ($\Delta t$) is represented by $\mathcal{H}_{\text{in}}$ and $\mathcal{H}_{\text{out}}$, respectively. $\mathcal{P}(\mathcal{H})$ represents the set of positive semi-definite operators with unitary trace acting on a Hilbert space $\mathcal{H}$. The channel $\mathcal{C}$ takes a quantum state $\rho\in\mathcal{H}_{\text{in}}$ at time $t$ and returns a quantum state $\rho'\in\mathcal{H}_{\text{out}}$ at time $t + \Delta t$. %See Figure~\ref{fig:NQS_scheme} for a description of the possible malicious behaviour. 

With this formulation, it's clear that the BQS model is a subset of the NQS. In BQS, the channel takes the form $\mathcal{C} = \mathds{1}^{\otimes \nu n}$, where the storage rate $\nu$ is the fraction of transmitted qubits stored in the quantum memory. The most commonly studied scenario is restricted to $n-$fold quantum channels ($\mathcal{C} = \mathcal{N}^{\otimes \nu n}$), where the channel $\mathcal{N}$ is applied independently to each stored qubit \cite{S10, KWW12, WST08}. In this scenario, specific security parameters can be derived.

%\begin{figure}
%    \centering
%    \includegraphics[scale=.1]{fig/nqs_channel.jpeg}
%    \caption{During waiting times $\Delta t$, the adversary must use his noisy quantum storage described by the CPTP map $\mathcal{C}$. Before using his quantum storage, he performs any (error-free) “encoding attack” of his choosing, which consists of a measurement or an encoding into an error-correcting code. After time $\Delta t$, he receives some additional information that he can use for decoding. Figure taken from \cite{WCSL10}.}
%    \label{fig:NQS_scheme}
%\end{figure}

\

\begin{figure}[h!]
\centering
\begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
                        
    \centerline{Na\"ive $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ \textbf{protocol}}
            
    \
    
    \textbf{Parameters:} $n$, security parameter; $\mathfrak{F}$ two-universal family of hash functions.
    
    \textbf{Alice's input:} $\bot$.  
    
    \textbf{Bob's input:} $\bot$. 
    
    \
    
    \textit{BB84 phase}: \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    
    
    \
    
    \textit{Waiting time phase}: \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ (Figure~\ref{fig:BBCS_Bounded}).}
    
    \
    
    \textit{Weak String Erasure phase}: \textcolor{gray}{Similar to \textit{Oblivious key phase} of $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    \begin{enumerate}
        \setcounter{enumi}{3}
        \item Alice reveals to Bob the bases $\bm{\theta}^{\mathsf{A}}$ used during the \textit{BB84 phase} and sets her oblivious key to $\mathsf{ok}^{\mathsf{A}}:=\bm{x}^{\mathsf{A}}$.
        
        \item Bob computes $\mathsf{e}^\mathsf{B} = \bm{\theta}^{\mathsf{B}} \oplus \bm{\theta}^{\mathsf{A}}$. Then, he defines $I = \{ i : \mathsf{e}^{\mathsf{B}}_i = 0 \}$ and sets $\mathsf{ok}^{\mathsf{B}}:=\bm{x}^{\mathsf{B}}_{I}$.
        
        \item If $|I| < n/4$, Bob randomly adds elements to $I$ and pads the corresponding positions in $\mathsf{ok}^{\mathsf{B}}$ with $0$s. Otherwise, he randomly truncates $I$ to size $n/4$, and deletes the corresponding values in $\mathsf{ok}^{\mathsf{B}}$.
    \end{enumerate}
     
    \ 
     
    \textit{Interactive hashing phase}: 
    \begin{enumerate}
        \setcounter{enumi}{6}
        \item Alice and Bob execute interactive hashing with Bob’s input $W$ to be equal to a description of $I = \mathsf{Enc}(W)$. They interpret the outputs $W_0$ and $W_1$ as descriptions of subsets $I_0$ and $I_1$ of $[n]$.
    \end{enumerate}
    
    \
    
    \textit{Transfer phase}:
            \begin{enumerate}
            \setcounter{enumi}{4}
                \item Alice generates random $f_0, f_1 \leftarrow_{\$}\mathfrak{F}$ and sends them to Bob.
                \item Alice computes the pair of messages $(m_0, m_1)$ as $m_i = f_i(\mathsf{ok}^{\mathsf{A}}_{I_{i}})$.
                \item Bob computes $b\in\{0, 1\}$ by comparing $I = I_b$ and computes $m_b = f_b(\mathsf{ok}^{\mathsf{B}}_{I})$. 
            \end{enumerate}
    
    
   
    
    \
    
$\mathsf{S}$ \textbf{output:} $(m_0, m_1)\in\{0,1\}^l$ (two messages).

$\mathsf{R}$ \textbf{output:} $(b, m_b)$ where $b\in\{0,1\}$ (bit choice).
    
\end{tcolorbox}
    \caption{BBCS OT protocol in the noisy-quantum-storage model.}
    \label{fig:BBCS_Noisy}
\end{figure}

\noindent\textbf{Protocols.} The BQS model protocol $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ is considered secure in the NQS model \cite{S10}. However, the first proposed protocol analysed in this general NQS model was developed by K\"onig et al. \cite{KWW12} and draws inspiration from classical OT in the bounded-classical-storage model \cite{CCM98, DHRS04, S07}. K\"onig et al.'s protocol uses two key techniques in its classical post-processing phase: encoding of sets and interactive hashing. The encoding of sets involves an injective function $\mathsf{Enc}: {0,1}^t \rightarrow T$, where $T$ is a set of all subsets of $[n]$ with size $n/4$. The interactive hashing is a two-party protocol between Alice and Bob where Bob inputs a message $W^t$ and both parties receive messages $W^t_0$ and $W^t_1$, with one of them equal to $W^t$, but with the index unknown to Alice and the choice randomly determined.  %A schematic representation of the interactive hashing functionality is given in Figure~\ref{fig:IH}.

%\begin{figure}[h!]
%    \centering
%    \includegraphics[scale=.1]{fig/Interactive_hashing.jpeg}
%    \caption{Interactive hashing functionality. Figure taken %from \cite{KWW12}.}
%    \label{fig:IH}
%\end{figure}


In this section, we present the na\"ive version of the protocol introduced by K\"onig et al. in \cite{KWW12}. Although both $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ are distinct, we maintain a similar notation for ease of comparison. The protocol $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ is outlined in Figure~\ref{fig:BBCS_Noisy}. The first two phases (\textit{BB84} and \textit{Waiting time}) are the same as in $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ (Figure~\ref{fig:BBCS_Bounded}).

After the \textit{Waiting time} phase, both parties generate a resource similar to oblivious keys, known as weak string erasure (WSE). Alice holds the entire key $\mathsf{ok}^{\mathsf{A}}$, while Bob holds one-fourth of it, represented by the tuple $(I, \mathsf{ok}^{\mathsf{B}} := \mathsf{ok}^{\mathsf{A}}_I)$, where $I$ is the set of indices they measured in the same basis and has size $|I| = \frac{n}{4}$. Using a method to encode sets into binary strings and interactive hashing, both parties generate two index subsets, $I_0$ and $I_1$. These subsets, along with two 2-universal hash functions, allow Alice to compute her output messages $(m_0, m_1)$ and Bob to obtain his bit choice $b$ and the corresponding message $m_b$. For more details on encoding sets and interactive hashing, refer to \cite{DHRS04} and \cite{S07}.


\

\noindent\textbf{Security.}  The first proofs in the NQS model for the original BQS protocol (Figure~\ref{fig:BBCS_Bounded}) were developed by Schaffner, Wehner, and Terhal \cite{WST08, STW09}. However, these initial works only considered individual-storage attacks, in which the adversary treats all incoming qubits equally. Schaffner later proved \cite{S10} the security of $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ against arbitrary attacks in the more general NQS model defined by K\"onig et al. \cite{KWW12}.

In the general NQS model, the security of both protocols $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ (Figures~\ref{fig:BBCS_Bounded} and \ref{fig:BBCS_Noisy}) against a dishonest receiver relies on setting a lower-bound for the min-entropy of the ``unknown'' key $\mathsf{ok}^{\mathsf{A}}_{I_{1-b}}$ given the receiver's quantum side information, represented by the output of the quantum channel $\mathcal{C}$ applied to the received states. More formally, one has to lower-bound the expression $H_{\text{min}}\left(\mathsf{ok}^{\mathsf{A}}_{I_{1-b}} | \mathcal{C}\left(Q_{\text{in}}\right)\right)$, where $Q_{\text{in}}$ denotes the subsystem of the received states before undergoing decoherence. This lower-bound, proven in \cite{KWW12}, depends on the receiver's maximal success probability $P^{\mathcal{C}}_{\text{succ}}(n)$ of correctly decoding a randomly chosen n-bit string $x \in \{0,1\}^n$ sent over the quantum channel $\mathcal{C}$.  %This result is given by Lemma~\ref{lemma:NQS_sec_lemma}.

%\begin{lemma}[Lemma II.2. from \cite{KWW12}]

%Consider an arbitrary ccq-state $\rho_{XTQ}$, and let $\varepsilon, \varepsilon' > 0$ be arbitrary. Let $\mathcal{C} : \mathcal{P}(\mathcal{H}_{Q_{\text{in}}}) \rightarrow \mathcal{P}(\mathcal{H}_{Q_{\text{out}}})$ be an arbitrary CPTP map, where $\mathcal{H}_{Q_{\text{in}}}$ and $\mathcal{H}_{Q_{\text{out}}}$ are the Hilbert space corresponding to the subsystem $Q_{\text{in}}$ and $Q_{\text{out}}$, respectively. Then,

%$$H^{\varepsilon + \varepsilon'}_{\min}(X|T\mathcal{C}(Q)) \geq -\log P^{\mathcal{C}}_{\text{succ}}\left(\left\lfloor H^{\varepsilon}_{\min}(X|T) - \log\frac{1}{\varepsilon}\right\rfloor \right),$$ where $H^{\epsilon}$ denotes the smooth min-entropy.

%\label{lemma:NQS_sec_lemma}
%\end{lemma}

For particular channels $\mathcal{C} = \mathcal{N}^{\otimes \nu }$, K\"onig et al. \cite{KWW12} concluded that security in the NQS model can be obtained in case
$$c_{\mathcal{N}} \cdot \nu < \frac{1}{2},$$
where $c_{\mathcal{N}}$ is the classical capacity of quantum channels $\mathcal{N}$ satisfying a particular property (strong-converse property).


\subsection{Experimental attacks}

While QKD and QOT protocols are proven to be secure in theory, their experimental implementations may contain loopholes that undermine their security. The mismatch between theory and practice stems from the fact that theoretical proofs often assume the honest parties' physical apparatus is invulnerable to hacking. However, flaws in both the generation and measurement of qubits can be used to carry out various quantum attacks. For a comprehensive overview of QKD attacks and countermeasures, we refer the reader to the review articles by Lo et al. \cite{LCT14} and Pirandola et al. \cite{Pirandola2020}. In this context, we briefly examine the impact of such attacks on QOT protocols based on BBCS.

\subsubsection{QOT attacks}

It is important to stress that there is a fundamental difference between QKD and QOT protocols. In QKD, the parties have a mutual trust and can work together to identify an external attack, while in QOT, the parties are inherently distrustful of each other. External attacks in QKD presume that the attacker has physical access to the quantum channel and can launch a man-in-the-middle attack. On the other hand, QOT protocols are inherently linked through a quantum channel, thus QOT attacks may require less effort to launch as the attacker is already utilizing the channel.




According to the security requirements of QOT protocols, it is crucial for both Alice and Bob to maintain their respective privacy. In particular, Alice should not know Bob's bit $b$, and Bob should not have knowledge of $m_{1-b}$. The security of BBCS-based QOT protocols depends on the security of oblivious keys, which requires Alice not to have information about the set of indexes known to Bob (i.e. $\mathsf{e}^\mathsf{B}$), and Bob having limited knowledge of Alice's key (i.e. $\mathsf{ok}^\mathsf{A}$). These two pieces of information can be easily obtained by the adversary if they have access to the quantum bases used by either party (i.e. $\bm{\theta}^{\mathsf{A}}$ or $\bm{\theta}^{\mathsf{B}}$).

For instance, Alice can compute $\mathsf{e}^\mathsf{B}$ by taking the XOR of $\bm{\theta}^{\mathsf{B}}$ and $\bm{\theta}^{\mathsf{A}}$, while Bob can obtain $\mathsf{ok}^\mathsf{A}$ by measuring all the qubits with Alice's bases $\bm{\theta}^{\mathsf{A}}$. Therefore, the objective of the adversary is to gain information (or control) about the set of bases used by the other party through their quantum channel.

Two common attacks in quantum systems are faked-state attacks (FSA) and trojan-horse attacks (THA) \cite{MH05, GFKZR06}. FSA targets measurement apparatus only, while THA can target both preparation and measurement apparatus. In a prepare-and-measure setting, FSA can only be executed by Alice, while THA can be executed by either party. In this context, let's examine how these two attacks can be applied to both $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\mathcal{F}_\textbf{COM}}$ protocols. The attacks on $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ follow the same reasoning but the notation vary slightly. 

We denote by $\tilde{\bm{\theta}}^{\mathsf{B}}_J \leftarrow \mathcal{A}_{\textbf{qok}}(J)$ Alice's quantum hacking procedure ($\mathcal{A}_{\textbf{qok}}(J)$) that breaks the security requirements of oblivious keys and provides her with Bob's bases ($\tilde{\bm{\theta}}^{\mathsf{B}}_J$) from index set $J$. Similarly for Bob, i.e. $\tilde{\bm{\theta}}^{\mathsf{A}}_J \leftarrow \mathcal{B}_{\textbf{qok}}(J)$.

\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{$\rotPi^{\mathsf{A}}_{\textbf{FSA}}$ attack}
            
            \
            
            \textbf{Alice's input:}  set of indexes $J$ of size $q$.
            
            \
 
 	\begin{enumerate}
         \item Alice performs some faked-state attack $\left\{\tilde{\theta}^{\mathsf{B}}_{j}\right\}_{j\in J} \leftarrow \mathcal{A}_{\textbf{qok}}(J) $ where $\tilde{\theta}^{\mathsf{B}}_{j}\in\{+, \times\}$ or $\tilde{\theta}^{\mathsf{B}}_{j}=\bot$. 
         \item If $\exists j\in J$ such that $\tilde{\theta}^{\mathsf{B}}_{j} \neq \bot$:
		\begin{enumerate}
            \item $b=0$ if $j\in I_b$, ;
            \item $b=1$ if $j\notin I_b$.
		\end{enumerate}
		\item Otherwise, sets $b = \bot$.
         
	\end{enumerate}            
            
            \
            
        \textbf{Alice's output:} $b$.

        
        \end{tcolorbox}
    \caption{Alice faked-state attack to $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\mathcal{F}_\textbf{COM}}$ protocols.}
    \label{fig:A_FSA}
\end{figure}

\

\noindent\textbf{FSA attacks.} The attacks described by Jain et al. \cite{JSKEML16} involve well-crafted optical signals that allow Alice to manipulate Bob's measurement outcomes. When Alice and Bob's bases coincide, Bob's detector clicks. Conversely, when their bases are orthogonal, Bob does not detect an event ($\bot$). Alice exploits this by forcing Bob to only use measurements where their bases coincide, thus gaining full knowledge of Bob's bases. By discarding the indexes corresponding to no detection events and using the others in the protocol, Alice can easily distinguish between $I_0$ and $I_1$.

It's worth noting that Alice only needs to successfully manipulate one measurement round in order to guess one basis, which occurs with high probability after a sufficient number of attacks $q$. The probability of success for Alice in $q$ rounds is calculated as follows: 
$$P[\text{Successful attack by Alice in }q\text{ rounds} ] = 1 - \bigg(\frac{1}{2}\bigg)^q.$$

With knowledge of Bob's basis, Alice can determine to which set ($I_0$ or $I_1$) a corresponding index ($j$) belongs. As Bob computes his message $m_b$ using the set where their basis coincides and Alice computes both messages $m_0$ and $m_1$ using both sets, Alice can determine Bob's message $m_b$ by identifying which message came from the set to which $j$ belongs. The attack $\rotPi^{\mathsf{A}}_{\textbf{FSA}}$ against both $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\mathcal{F}_\textbf{COM}}$ is summarized in Figure~\ref{fig:A_FSA}.


\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{$\rotPi^{\mathsf{A}}_{\textbf{THA}}$ attack}
            
            \
            
            \textbf{Alice's input:}  one index element, $j$.
            
            \
            
            \begin{enumerate}
         \item Alice performs some trojan-horse attack $\left\{\tilde{\theta}^{\mathsf{B}}_{j}\right\} \leftarrow \mathcal{A}_{\textbf{qok}}(i) $ where $\tilde{\theta}^{\mathsf{B}}_{j}\in\{+, \times\}$.
         \item Alice compares the received basis $\tilde{\theta}^{\mathsf{B}}_{j}$ with her corresponding base $\theta^{\mathsf{A}}_{j}$. Denote by $\tilde{\mathsf{e}}^{\mathsf{B}}_j := \tilde{\theta}^{\mathsf{B}}_{j} \oplus \theta^{\mathsf{A}}_{j}$. 
         \item Upon receiving $I_b$ from R:
         \begin{enumerate}
             \item $b=\tilde{\mathsf{e}}^{\mathsf{B}}_j$ if $j\in I_b$;
             \item $b=1-\tilde{\mathsf{e}}^{\mathsf{B}}_j$ if $j\notin I_b$.
         \end{enumerate}
         
    \end{enumerate}    
            
            \
            
        \textbf{Alice's output:} $b$.

        
        \end{tcolorbox}
    \caption{Alice trojan-horse attack to $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\mathcal{F}_\textbf{COM}}$ protocols.}
    \label{fig:A_THA}
\end{figure}

\

\noindent\textbf{THA attacks.} These attacks are executed by sending bright optical signals into the target equipment and analyzing the different reflections to determine the bases in use. Similarly to the FSA, Alice only needs to identify one of Bob's bases to compromise the system. By comparing her basis with Bob's basis for that particular round, she can determine Bob's bit $b$. This attack is depicted in Figure~\ref{fig:A_THA} as $\rotPi^{\mathsf{A}}_{\textbf{THA}}$.

Bob's THA attack, on the other hand, is more challenging. He must not only accurately guess all of Alice's bases but also properly measure the corresponding qubits after revealing the sender's bases. This task is much more difficult without the assistance of quantum memories. Bob's attack is illustrated in Figure~\ref{fig:B_THA} as $\rotPi^{\mathsf{B}}_{\textbf{THA}}$.





%This is more problematic if Bob undertakes passive basis choice (e.g. the basis choice is achieved by Bob's set-up randomly at the polarizing beam splitter)


%To be more specific, even if Alice is able to find only \textit{one} Bob's choice base of the $j-$th index, she can perfectly guess Bob's bit choice $b$ when she receives the index set $I_b$. The attack is described in Figure~\ref{}. On the other hand, Bob's attack is more challenging because he has to successfully guess \textit{all} Alice's basis. Besides that, Bob attack is technologically more challenging than Alice's. This is because Bob has to be able to leak Alice basis and immediately measure the corresponding qubit. Otherwise, in case he has access to quantum memory he can hold the qubits before measuring them. However, this is unfeasible with current technology. Bob's attack is summarized in Figure~\ref{A_FSA}.

\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{$\rotPi^{\mathsf{B}}_{\textbf{THA}}$ attack}
            
            \
            
            \textbf{Parameters:}  $n$, security parameter..
            
            \
            
            \begin{enumerate}
         \item Bob performs some trojan-horse attack to all qubits sent by Alice, i.e. $\left\{\tilde{\theta}^{\mathsf{A}}_{i}\right\}_{i\in [n]} \leftarrow \mathcal{B}_{\textbf{qok}}([n]) $ where $\tilde{\theta}^{\mathsf{A}}_{i}\in\{+, \times\}$.
         \item Bob measures the received states $\ket{\bm{x}^{\textsf{A}}}_{\bm{\theta}^{\textsf{A}}}$ with the correct bases, $\left\{\tilde{\theta}^{\mathsf{A}}_{i}\right\}_{i\in [n]}$. 
    \end{enumerate}    
            
            \
            
        \textbf{Bob's output:} $\mathsf{ok}^{\mathsf{A}}$.

        
        \end{tcolorbox}
    \caption{Bob trojan-horse attack to $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\mathcal{F}_\textbf{COM}}$ protocols.}
    \label{fig:B_THA}
\end{figure}




\subsubsection{Countermeasures}

We have seen how two well-known quantum hacking techniques can undermine the security of oblivious keys and, consequently, the security of oblivious transfer. Fortunately, there are countermeasures available to prevent these quantum hacking techniques from compromising the security of oblivious keys and, in turn, oblivious transfer. These countermeasures can be classified into two categories: security patches designed to address specific vulnerabilities and novel protocols that allow for the use of faulty devices.

Regarding the two presented possible attacks, it is commonly possible to implement security patches that prevent them. The FSA attack can be mitigated by placing an additional detector (watchdog) at the entrance of the receiver's measurement device to monitor for malicious radiation that blinds the detector. On the other hand, the THA attack can be prevented by using an isolator at the entrance of both parties' devices. However, as noted by Jain et al. \cite{JSKEML16}, these countermeasures may not be foolproof in practice as they only offer perfect protection if the isolators and watchdogs are effective at all relevant frequencies.

The study of security patches for each technological vulnerability is an active area of research \cite{JBI+16}. However, this approach requires a challenging task of making experimental implementations match ideal protocols, leading to potential security vulnerabilities. Instead, it is more advantageous to develop protocols that already account for faulty devices and are robust against quantum hacking attacks. This is the objective of device-independent (DI) cryptography, where quantum devices are treated as black-boxes and the assumption that they cannot be controlled by the adversary is dropped \cite{MY04, E91}. This section provides a brief overview of the current advancements in DI protocols. For a more comprehensive understanding, refer to the original works.

\

\noindent\textbf{Kaniewski-Wehner DI protocol \cite{KW16}.} The first DI protocol for QOT was proposed by Kaniewski and Wehner \cite{KW16} and further improved by Ribeiro et al. in \cite{RTK+18}.  The protocol was proved to be secure in the noisy-quantum-storage (NQS) model as it uses the original NQS protocol $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ (Figure~\ref{fig:BBCS_Noisy}) for trusted devices.

The protocol considers two scenarios. The first assumes that the devices have a memoryless behavior every time they are used, which enables the devices to be tested independently from the actual protocol, resulting in a DI protocol with two phases: a device-testing phase and a protocol phase. Under this memoryless assumption, the protocol is proven to be secure against general attacks using proof techniques from \cite{KWW12}. The second scenario removes the memoryless assumption, making it unrealistic to test the devices in advance, as their behavior can change. As a result, the structure of the initial DI protocol must be altered, interweaving the rounds of the device-testing phase with the rounds of the protocol phase.

As is typical in DI protocols, the DI property arises from a violation of Bell inequalities \cite{AGM06} that ensures a certain level of entanglement. In the protocol phase, the entanglement-based variant of $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ must be used, with Alice preparing maximally entangled states $\ketbra{\Phi^+}$, where $\ket{\Phi^+} = \frac{1}{\sqrt{2}}(\ket{00} + \ket{11})$. The Bell inequality used in this case is based on the Clauser-Holt-Shimony-Horne (CHSH) inequality \cite{CHSH69}.


\

\noindent\textbf{Broadbent-Yuen DI protocol \cite{BY21}.} Recently, Broadbent and Yuen \cite{BY21} proposed a DI protocol in the BQS (bounded-quantum-storage) model using $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ (Figure~\ref{fig:BBCS_Bounded}). Like the work of Kaniewski and Wehner \cite{KW16}, the protocol is secure under the memoryless assumption, but with a difference. Unlike Kaniewski and Wehner's work, which relies on the violation of Bell inequalities \cite{AGM06} for security, Broadbent and Yuen's protocol does not require non-communication assumptions. Instead, it employs a recent self-testing protocol \cite{MDC+21, MV21} that is based on the hardness of the Learning with Errors (LWE) problem \cite{P15}. This approach allows the protocol to be secure without relying on the violation of Bell inequalities.

\

\noindent\textbf{Ribeiro-Wehner MDI protocol \cite{RW20}.} In the work by Ribeiro and Wehner \cite{RW20}, an OT protocol in the measurement-device-independent (MDI) regime \cite{LCQ12} was developed to tackle the technological difficulties in implementing DI protocols \cite{MDR+19}. The MDI regime assumes that the measurement devices are untrusted while the sources are trusted. This protocol was motivated by the lack of security proof in the DI setting and the vulnerability of non-device-independent protocols to attacks on the measurement devices \cite{SRK+15}. The presented protocol follows the research line of K\"onig et al. \cite{KWW12} and is also proved to be secure in the NQS model.

The protocol starts with a weak string erasure (MDI-WSE) phase, similar to the approach taken by K\"onig et al. \cite{KWW12}. In this phase, Alice and Bob send random states $\ket{\bm{x}^{\mathsf{A}}}_{\bm{\theta}^{\mathsf{A}}}$ and $\ket{\bm{x}^{\mathsf{B}}}_{\bm{\theta}^{\mathsf{B}}}$ to an external agent who performs a Bell measurement and announces the result. Bob adjusts his bit to match Alice's based on the announcement. Subsequently, both parties proceed with the $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ protocol (Figure~\ref{fig:BBCS_Noisy}) from the waiting time phase onward. A similar protocol was proposed by Zhou et al. \cite{ZGG+20} which includes error estimation to enhance security.

%This \textit{security patches} strategy only tries to approximate the experimental implementation to the ideal protocol. However, since the ideal protocol does not assume faulty devices this task is very difficult to accomplish. A better approach to mitigate these securities issues is the development of novel schemes that allow faulty devices. This is the main aim of device-independent protocols which treat both sender and receiver devices as block boxes with minimal security guarantees. To the best of our knowledge, there are only two proposed DI protocols for oblivious keys \cite{KW16, BY21}. However, Kaniewski's protocol \cite{KW16} is just proven to be secure against sequential attacks and Broadbent's protocol \cite{BY21} uses post-quantum computational assumption. 

%To avoid the technological challenges of DI protocols, we can relax its security levels and work in the measurement-device-independent (MDI) setting. This approach allows two parties to perform QOKD with untrusted measurement devices while trusting in their sources. However, Ribeiro et al. \cite{RW20} showed that although the protocol is secure with ideal photon sources, it is not proven to be secure with imperfect sources.




%\bibliography{bibforthesis}
%\bibliographystyle{unsrt}
%\end{document}
