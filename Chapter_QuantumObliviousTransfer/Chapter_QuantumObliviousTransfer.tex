%\documentclass[11pt]{report}



%\begin{document}

\chapter{Quantum Oblivious Transfer}\label{chapter_QOT}
%\addcontentsline{toc}{chapter}{Introduction}


In a recent survey on classical oblivious transfer (OT) \cite{YAVV22}, all the analysed protocols require some form of asymmetric cryptography. Indeed, in the classical setting, it is impossible to develop information-theoretic secure OT or even reduce it to one-way functions, requiring some public-key computational assumptions. As shown by Impaggliazzo and Rudich \cite{IR89}, one-way functions (symmetric cryptography) alone do not imply key agreement (asymmetric cryptography). Also, Gertner et al. \cite{GKMRV00} pointed out that since it is known that OT implies key agreement, this sets a separation between symmetric cryptography and OT, leading to the conclusion that OT cannot be generated alone by symmetric cryptography. Otherwise, one could use one-way functions to implement key agreement through the OT construction. This poses a threat to all classical OT protocols \cite{EGL85, NP01, CO15} that are based on mathematical assumptions provably broken by a quantum computer \cite{Sho95}. Besides the security problem, asymmetric cryptography tends to be computationally more complex than symmetric cryptography, creating a problem in terms of speed when a large number of OTs are required. The classical post-quantum approach, thrives to find protocols resistant against quantum computer attacks. However, these are still based on complexity problems and are not necessarily less computationally expensive, than the previously mentioned ones. 

In parallel to the classical post-quantum approach, the quantum cryptography community tackled this security issue by presenting some OT protocols based on quantum technologies. Intriguingly enough, more than a decade before the first classical OT by Rabin (1981, \cite{Rabin81}) was published, Wiesner proposed a similar concept. However, at the time, it was rejected for publication due to the lack of acceptance in the research community. The first published quantum OT (QOT) protocol, known as the BBCS (Bennett-Brassard-Cr{\'e}peau-Skubiszewska) protocol \cite{BBCS92} was only presented in 1992. Remarkably, there is a distinctive difference between classical and quantum OT from a security standpoint, as the latter is proved to be possible assuming only the existence of quantum-hard one-way functions \cite{GLSV21, BCKM21}. This means quantum OT requires weaker security assumptions than classical OT.

In this chapter, we review the particular topic of quantum OT. We mainly comment on several important OT protocols, their underlying security models and assumptions. To the best of our knowledge, there is no prior survey dedicated to quantum OT protocols alone. Usually, its analysis is integrated into more general surveys under the topic of ``quantum cryptography", leading to a less in-depth exposition of the topic. For reference, we provide some distinctive reviews on the general topic of quantum cryptography \cite{BC96, B05, M06, F10, B15, PAB+20, PR21, SH22}.

This chapter is divided as follows. We start by giving a brief overview of the impossibility results related to quantum OT. Then, we provide an exposition about some of the most well-known quantum OT protocols based on assumptions. Finally, we give a brief overview of OT protocols not covered throughout this thesis.

%********************************** %First Section  **************************************
\section{Impossibility results}

The beginning of the development of quantum OT (QOT) came hand in hand with the development of quantum bit commitment (QBC). In fact, the first proposed QOT protocol (BBCS \cite{BBCS92}) reduces QOT to QBC . This sets a distinctive difference between classical and quantum protocols. Although bit commitment (BC) can be reduced to oblivious transfer (OT) \cite{K88}, the reverse is not true using only classical communication \cite{S99}. Therefore, Yao's proof \cite{Y95} of BBCS protocol \cite{BBCS92} gives quantum communications the enhanced quality of having an equivalence between QOT and QBC - they can be reduced to each other - a relation that is not known in the classical realm.

At the time of the BBCS protocol, the quest for unconditionally secure QOT was based on the possibility of unconditional secure QBC. A year later, Brassard et al. presented a QBC protocol \cite{BCJL93} named after the authors, BCJL (Brassard-Crépeau-Jozsa-Langlois). However, this work presented a flawed proof of its unconditional security which was generally accepted for some time, until Mayers spotted an issue on it \cite{M96}. Just one year after, Lo and Chau \cite{LC97}, and Mayers \cite{M97} independently proved unconditional QBC to be impossible. Nevertheless, the existence of unconditionally secure QOT not based on QBC was still put as an open question \cite{BC96} even after the so-called no-go theorems \cite{LC97, M97}. However, Lo was able to prove directly that unconditionally secure QOT is also impossible \cite{L97}. He concluded this as a corollary of a more general result that states that secure two-party computations which allow only one of the parties to learn the result (one-side secure two-party computation) cannot be unconditionally secure. Lo's results triggered a line of research on the possibility of two-sided secure two-party computation (both parties are allowed to learn the result without having access to the other party's inputs), which was also proved by Colbeck to be impossible \cite{C07} and extended in subsequent works \cite{BCS12, SSS14, SJFHV13}. For a more in-depth review of the impossibility results presented by Lo, Chau and Mayers, we refer the interested reader to the following works \cite{BCMS97, S99}.

Although the impossibility results have been well accepted in the quantum cryptography community, there was some criticism regarding the generality of the results \cite{Y00, Y02, Y04, C03}. This line of research reflects the view put forward by Yuen \cite{Y00} in the first of these papers: ``Since there is no known characterization of all possible QBC protocols, logically there can really be no general impossibility proof, strong or not, even if it were indeed impossible to have an unconditionally secure QBC protocol.'' In parallel, subsequent analyses were carried out, reaffirming the general belief of impossibility \cite{B01, C05, Che07}. However, most of the discord has ended with Ariano et al. proof \cite{A07} in 2007, giving an impossibility proof covering all conceivable protocols based on classical and quantum information theory. Subsequent work digested Ariano et al. \cite{A07} work, trying to present more succinct proofs \cite{CAP10, CAPSW13, H13} and to translate it into categorical quantum mechanics language \cite{K12, SHW20, BK22}. 

Facing these impossibility results, the quantum cryptography community followed two main paths:

\begin{enumerate}
    \item Develop OT protocols under some assumptions. These could be based on limiting the technological power of the adversary (e.g. noisy-storage model, relativistic protocols, isolated-qubit model) or assuming the security of additional functionalities (e.g. bit commitment).
    \item Develop OT protocols with a relaxed security definition. These allow the adversary to extract, with a given probability, some information (partial or total) about the honest party input/output. This approach leads to the concepts of weak OT  and weak private database query.
\end{enumerate}

In the next section, we explore protocols that produce a special primitive called \textit{oblivious keys} as an intermediate step.


%********************************** %Second Section  **************************************
\section{BBCS-based protocols}

In this section, we explore protocols that circumvent the no-go theorems \cite{LC97, M97} through assumptions. Some of the presented solutions are based on one-way functions, which are believed to be quantum-hard \cite{BCKM21, GLSV21,A02}, and others rely on technological or physical limitations of the adversaries \cite{DFSS05, WST08, KWW12, L14, Pit16, Ken11}. The latter are qualitatively different from complexity-based assumptions on which post-quantum protocols rely. Also, all these assumptions have the important property that they only have to hold during the execution of the protocol for its security to be preserved. In other words, even if the assumptions lose their validity at some later point in time, the security of the protocol is not compromised. This property is commonly known as \textit{everlasting} security \cite{U18}. Everlasting security is also a major distinctive feature of quantum protocols when compared with classical cryptographic approaches.

We start by presenting the first QOT protocol. Then, we see how this protocol led to the development of two assumption models: $\mathcal{F}_{\text{COM}}-$hybrid model and the limited-quantum-storage model. 

\subsection{BBCS protocol}\label{sec:BBCS}

{\cv Notation conflict: $\mathcal{F}$ to denote universal functions}

In 1983, Wiesner came up with the idea of \textit{quantum conjugate coding} \cite{W83}. This technique is the main building block of many important quantum cryptographic protocols \cite{BB84, BBBW83, DFSS14}, including quantum oblivious transfer \cite{BBCS92}. It also goes under the name of \textit{quantum multiplexing} \cite{BBBW83}, \textit{quantum coding} \cite{BBB14} or \textit{BB84 coding} \cite{S99}. In quantum conjugate coding we encode classical information in two conjugate (non-orthogonal) bases. This allows us to have the distinctive property that measuring on one basis destroys the encoded information on the corresponding conjugate basis. So, when bit $0$ and $1$ are encoded by these two bases, no measurement is able to perfectly distinguish the states. We will be using the following bases in the two-dimensional Hilbert space $\mathcal{H}_2$:

\begin{itemize}
    \item Computational basis: $+ := \left\{\ket{0}_{+}, \ket{1}_{+}\right\}$;
    \item Hadamard basis: $\times := \left\{\ket{0}_{\times}, \ket{1}_{\times}\right\} = \left\{\frac{1}{\sqrt{2}}\big( \ket{0}_{+} + \ket{1}_{+} \big), \frac{1}{\sqrt{2}}\big( \ket{0}_{+} - \ket{1}_{+} \big) \right\}$.
\end{itemize}

Throughout this chapter we abuse the notation and consider that the set of bases $\{+,\times\}$ can be associated with the binary set $\{0,1\}$. $+$ is associated with $0$ and $\times$ with $1$. This is specially useful to compare strings of bases from different parties, i.e. the XOR operation ($\oplus$) between two vectors $\bm{\theta}^{\mathsf{A}}, \bm{\theta}^{\mathsf{B}} \in\{+,\times\}^n$ is defined as the XOR between the corresponding binary vectors $\bm{\theta}^{\mathsf{A}}, \bm{\theta}^{\mathsf{B}} \in\{0,1\}^n$.

\

\noindent\textbf{Protocol \cite{BBCS92}.} The first proposal of a quantum oblivious transfer protocol is presented in Figure~\ref{fig:BBCS} and it is called after its creators, Bennett-Brassard-Cr{\'e}peau-Skubiszewska (BBCS). It builds on top of the quantum conjugate coding technique. Alice starts by using this encoding to generate a set of qubits that are subsequently randomly measured by Bob. These two steps make up the first phase of the BB84 QKD protocol. For this reason, this is called the \textit{BB84 phase}. Next, both parties use the output bits obtained from Bob and the random elements generated by Alice to share a special type of key, known as \textit{oblivious key}. This is achieved when Alice reveals her bases $\bm{\theta}^{\mathsf{A}}$ to Bob. Using the oblivious key as a resource, Alice can then obliviously send one of the messages $m_0, m_1$ to Bob, ensuring that he is only able to know one of the messages. This is achieved using a two-universal family of hash functions $\mathcal{F}$ from $\{0,1\}^{n/2}$ to $\{0,1\}^{l}$. Recall, we use the notation $s\leftarrow_{\$}S$ to describe a situation where an element $s$ is drawn uniformly at random from the set $S$.

\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{$\Pi^{\textbf{BBCS}}$ \textbf{protocol}}
            
            \
            
            \textbf{Parameters:} $n$, security parameter; $\mathcal{F}$ two-universal family of hash functions.
            
            \textbf{Alices's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
            
            \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
            
            \
            
            \textit{BB84 phase}:
            \begin{enumerate}
                \item Alice generates random bits $\bm{x}^{\mathsf{A}}\leftarrow_{\$}\{0,1\}^n$ and random bases $\bm{\theta}^{\mathsf{A}}\leftarrow_{\$}$~$\{+,\times\}^n$. Sends the state $\ket{\bm{x}^{\mathsf{A}}}_{\bm{\theta}^{\mathsf{A}}}$ to Bob.
                \item Bob randomly chooses bases $\bm{\theta}^{\mathsf{B}}\leftarrow_{\$}$~$\{+,\times\}^n$ to measure the received qubits. We denote by $\bm{x}^{\mathsf{B}}$ his output bits.
            \end{enumerate}
            
            \
            
            \textit{Oblivious key phase}:
            \begin{enumerate}
            \setcounter{enumi}{2}
                \item Alice reveals to Bob the bases $\bm{\theta}^{\mathsf{A}}$ used during the \textit{BB84 phase} and sets his oblivious key to $\mathsf{ok}^{\mathsf{A}}:=\bm{x}^{\mathsf{A}}$.
                \item Bob computes $\mathsf{e}^\mathsf{B} = \bm{\theta}^{\mathsf{B}} \oplus \bm{\theta}^{\mathsf{A}}$ and sets $\mathsf{ok}^{\mathsf{B}}:=\bm{x}^{\mathsf{B}}$.
            \end{enumerate}
            
            \
            
            \textit{Transfer phase}:
            \begin{enumerate}
            \setcounter{enumi}{4}
                \item Bob defines $I_0 = \{ i : \mathsf{e}^{\mathsf{B}}_i = 0 \}$ and $I_1 = \{ i : \mathsf{e}^{\mathsf{B}}_i = 1 \}$ and sends the set $I_b$ to Alice.
                \item Alice picks two uniformly random hash functions $f_0, f_1 \in \mathcal{F}$, computes the pair of strings $(s_0, s_1)$ as $s_i = m_i \oplus f_i(\mathsf{ok}^{\mathsf{A}}_{I_{b\oplus i}})$ and sends the pairs $(f_0, f_1)$ and $(s_0, s_1)$ to Bob.
                \item Bob computes $m_b = s_b \oplus  f_i(\mathsf{ok}^{\mathsf{B}}_{I_0})$. 
            \end{enumerate}
            
            \
            
        \textbf{Alice's output:} $\bot$.
        
        \textbf{output:} $m_b$.
        
        \end{tcolorbox}
    \caption{BBCS OT protocol.}
    \label{fig:BBCS}
\end{figure}

\

\noindent\textbf{Oblivious keys.}  As we saw in the BBCS protocol, oblivious keys can be used as a resource to produce OT instances. In fact, we can draw a comparison between standard encryption keys and oblivious keys. In the same way as standard keys are the resource that allows the encryption of a specific message, oblivious keys are the resource that enables the performance of OT with messages. In other words, encryption methods consume standard keys, while OT methods consume oblivious keys. The term, oblivious key, was used for the first time by Fehr and Schaffner \cite{FS09} referring to random OT. However, under a subtle different concept, it was put forth by Jakobi et al. \cite{JSGBBWZ11} and used to implement private database queries (PDQ). Also, in a recent work, Lemus et al. \cite{Lemus20} presented the concept of oblivious key applied to OT protocols. We can define it as follows.

\begin{definition}[Oblivious key]
An oblivious key shared between two parties, Alice and Bob, is a tuple $\mathsf{ok}:= \big( \mathsf{ok}^{\mathsf{A}}, (\mathsf{ok}^{\mathsf{B}}, \mathsf{e}^{\mathsf{B}}) \big)$ where $\mathsf{ok}^{\mathsf{A}}$ is Alice's key, $\mathsf{ok}^{\mathsf{B}}$ is Bob's key and $\mathsf{e}^{\mathsf{B}}$ is Bob's signal string. $\mathsf{e}^{\mathsf{B}}$ indicates which indexes of $\mathsf{ok}^{\mathsf{A}}$ and $\mathsf{ok}^{\mathsf{B}}$ are correlated and which indexes are uncorrelated, i.e. $\mathsf{e}^{\mathsf{B}}_i = 0$ when the corresponding indexes are correlated and $\mathsf{e}^{\mathsf{B}}_i = 1$ when they are not.
\label{def:ok}
\end{definition}

Note that, for some index $i$, when two index elements $\mathsf{ok}^{\mathsf{A}}_i$ and $\mathsf{ok}^{\mathsf{B}}_i$ are correlated, $\mathsf{ok}^{\mathsf{A}}_i=\mathsf{ok}^{\mathsf{B}}_i$. However, when they are uncorrelated, they are drawn independently. This means that both index elements may either be equal or different. Consider the following oblivious key $\mathsf{ok}=\left( 001101101101, \left( 000101001100, 101000110001 \right) \right)$ as an example. We can check it is a well strucured oblivious key:

\begin{equation*}
    \left.\begin{array}{cc}
      \mathsf{ok}^{\mathsf{A}} :& \tikzmarkin{a}\red{0}\,\,\,\, \tikzmarkin{b}\green{0}\,\,\,\, \tikzmarkin{c}\red{1}\,\,\,\, \tikzmarkin{d}\green{1}\,\,\,\, \tikzmarkin{e}\green{0}\,\,\,\, \tikzmarkin{f}\green{1}\,\,\,\, \tikzmarkin{g}\red{1}\,\,\,\, \tikzmarkin{h}\red{0}\,\,\,\, \tikzmarkin{i}\green{1}\,\,\,\, \tikzmarkin{j}\green{1}\,\,\,\, \tikzmarkin{k}\green{0}\,\,\,\, \tikzmarkin{l}\red{1}  \\
      \mathsf{ok}^{\mathsf{B}} :& \red{0}\,\,\,\, \green{0}\,\,\,\, \red{0}\,\,\,\, \green{1}\,\,\,\, \green{0}\,\,\,\, \green{1}\,\,\,\, \red{0}\,\,\,\, \red{0}\,\,\,\, \green{1}\,\,\,\, \green{1}\,\,\,\, \green{0}\,\,\,\, \red{0} \\
      \mathsf{e}^{\mathsf{B}} :& \red{1}\tikzmarkend{a}\,\,\,\, \green{0}\tikzmarkend{b}\,\,\,\, \red{1}\tikzmarkend{c}\,\,\,\, \green{0}\tikzmarkend{d}\,\,\,\, \green{0}\tikzmarkend{e}\,\,\,\, \green{0}\tikzmarkend{f}\,\,\,\, \red{1}\tikzmarkend{g}\,\,\,\, \red{1}\tikzmarkend{h}\,\,\,\, \green{0}\tikzmarkend{i}\,\,\,\, \green{0}\tikzmarkend{j}\,\,\,\, \green{0}\tikzmarkend{k}\,\,\,\, \red{1}\tikzmarkend{l}
    \end{array}\right\} \mathsf{ok}
\end{equation*}

It is worth stressing that oblivious keys are independent of the sender's messages  $m_0, m_1$ and are not the same as random OT. In fact, as Alice does not know the groups of indexes $I_0$ and $I_1$ computed by Bob after the basis revelation, Alice does not have her messages fully defined. A similar concept was defined by K\"onig et al.  \cite{KWW12} under the name of \textit{weak string erasure}. 

\

\noindent\textbf{Security.} Regarding security, the BBCS protocol is unconditionally secure against dishonest Alice. Intuitively, this comes from the fact that Alice does not receive any information from Bob other than some set of indexes $I_0$. However, the BBCS protocol is insecure against dishonest Bob. In its original paper \cite{BBCS92}, the authors describe a memory attack that provides Bob complete knowledge on both messages $m_0$ and $m_1$ without being detected. This can be achieved by having the receiver delay his measurements in step 2 to some moment after step 3. This procedure is commonly called the memory attack as it requires quantum memory to hold the states until step 3. The authors suggest that, for the protocol to be secure, the receiver has to be forced to measure the received states at step 2. In the following sections, we present two common approaches to tackle this issue. We may assume the existence of commitments or set physical assumptions that constrain Bob from delaying his measurement.


\subsection{BBCS in the $\mathcal{F}_{\textbf{COM}}-$hybrid model}\label{BBCS-com-hybrid}

As mentioned in the previous section, a secure BBCS protocol requires Bob to measure his qubits in step 2. In this section, we follow the suggestion from the original BBCS paper \cite{BBCS92} and fix this loophole using a commitment scheme. Since we assume we have access to some commitment scheme, we call it $\mathcal{F}_{\textbf{COM}}-$hybrid model\footnote{The notation $\mathcal{F}_{\textbf{COM}}$ is commonly used for ideal functionalities. However, here we abuse the notation by using $\mathcal{F}_{\textbf{COM}}$ to refer to any commitment scheme (including the ideal commitment functionality).}.

\begin{figure}[h!]
\centering
\begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
                        
    \centerline{$\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ \textbf{protocol}}
            
    \
    
    \textbf{Parameters:} $n$, security parameter; $\mathcal{F}$ two-universal family of hash functions.
    
    \textbf{Alice's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
    
    \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
    
    \
    
    \textit{BB84 phase:} \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    
    
    \
    
    \textit{Cut and choose phase}:
    \begin{enumerate}
    \setcounter{enumi}{2}
        \item Bob commits to the bases used and the measured bits, i.e. $\textbf{COM}\big(\bm{\theta}^\mathsf{B}, \bm{x}^\mathsf{B}\big)$, and sends to Alice. %using $\mathcal{F}_{\textbf{com}}$.
        \item Alice asks Bobto open a subset $T$ of commitments (e.g. $n/2$ elements) and receives $\{\theta_i^\mathsf{B}, x_i^\mathsf{B}\}_{i\in T}$.% from $\mathcal{F}_{\textbf{com}}$.
        \item In case any opening is not correct or $x_i^\mathsf{B} \neq x_i^\mathsf{A}$ for $\theta_i^\mathsf{B} = \theta_i^\mathsf{A}$, abort. Otherwise, proceed. 
    \end{enumerate}
    
    \
    
    \textit{Oblivious key phase:} \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
     
    \
     
    \textit{Transfer phase:} \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    
    \
    
\textbf{Alice's output:} $\bot$.

\textbf{Bob's output:} $m_b$.
    
\end{tcolorbox} 
    \caption{BBCS OT protocol in the $\mathcal{F}_{\textbf{COM}}-$hybrid model.}
    \label{fig:BBCS_COM}
\end{figure}

\noindent\textbf{Protocol.} The modified BBCS (Figure~\ref{fig:BBCS_COM}) adds a \textit{cut and choose} phase that makes use of a commitment scheme \textbf{COM} to check whether Bob measured his qubits in step 2 or not. It goes as follows. Bob commits to the bases used to measure the qubits in the \textit{BB84 phase} and the resulting output bits. Then,Alice chooses a subset of qubits to be tested and asks Bob to open the corresponding commitments of the bases and output elements. If no inconsistency is found, both parties can proceed with the protocol. Note that the size of the testing subset has to be proportional to $n$ (security parameter), as this guarantees that the rest of the qubits were measured by Bob with overwhelming probability in $n$.

\

\noindent\textbf{Security.} Formally proving the security of this protocol led to a long line of research \cite{CK88, BBCS92, MS94, Y95, M96b, CDMS04, FS09, DFLSS09, U10, BF10, GLSV21, BCKM21}. Earlier proofs from the $90$'s started by analyzing the security of the protocol against limited adversaries that were only able to do individual measurements \cite{MS94}. Then, Yao \cite{Y95} was able to prove its security against more general adversaries capable of doing fully coherent measurements. Although these initial works \cite{MS94, Y95, M96b} were important to start developing a QOT security proof, they were based on unsatisfactory security definitions. At the time of these initial works, there was no composability framework \cite{FS09, U10} under which the security of the protocol could be considered. In modern quantum cryptography, these protocols are commonly proved in some quantum simulation-paradigm frameworks \cite{FS09, U10, DFLSS09, KWW12}. In these paradigms, the security is proved by showing that an adversary in a real execution of the protocol cannot cheat more than what he is allowed in an ideal execution, which is secure by definition. This is commonly proved by utilizing an entity, called simulator, whose role is to guarantee that a real execution of the protocol is indistinguishable from an ideal execution. Moreover, they measured the adversary's information through average-case measures (e.g. Collision Entropy, Mutual Information) which are proven to be weak security measures when applied to cryptography \cite{BCC+10, TR11}.

More desirable worst-case measures started to be applied to quantum oblivious transfer around a decade later \cite{R06, DFRSS07}. These were based on the concept of \textit{min-entropy} \cite{BCC+10,TR11}, $H_{\text{min}}$, which, intuitively, reflects the maximum probability of an event to happen. More precisely, in order to prove security against dishonest Bob, one is interested in measuring Bob's min-entropy on Alice's oblivious key $\mathsf{ok}^{\mathsf{A}}$ conditioned on some quantum side information $E$ he may has, i.e. $H_{\text{min}}(\mathsf{ok}^{\mathsf{A}} | E)$. Informally, for a bipartite classical-quantum state $\rho_{X E}$ the conditional min-entropy $H_{\text{min}}(X | E)$ is given by 

$$H_{\text{min}}(X | E)_{\rho_{X E}} := -\log P_{guess}(X|E),$$
where $P_{guess}(X|E)$ is the probability the adversary guesses the value $x$ maximized over all possible measurements. Damg{\aa}rd et al. \cite{DFLSS09} were able to prove the stand-alone QOT security when equipped with this min-entropy measure and with the quantum simulation-paradigm framework developed by Fehr and Schaffner \cite{FS09}. Their argument to prove the security of the protocol against dishonest Bob can be summarized as follows. The cut and choose phase ensures that Bob's conditional min-entropy on the elements of $\mathsf{ok}^{\mathsf{A}}$ belonging to $I_{1}$ (indexes with uncorrelated elements between Alice's and Bob's oblivious keys) is lower-bounded by some value that is proportional to the security parameter, i.e. $H_{\text{min}}(\mathsf{ok}^{\mathsf{A}}_{I_{1}} | E) \geq n\lambda$ for some $\lambda > 0$. Note that this is equivalent to derive an upper bound on the guessing probability $P_{guess}(\mathsf{ok}^{\mathsf{A}}_{I_{1}}|E) \leq 2^{-n\lambda}$. Having deduced an expression for $\lambda$, they proceed by applying a random hash function $f$ from a two-universal family $\mathcal{F}$, $f\leftarrow_{\$}\mathcal{F}$. This final step ensures that $f(\mathsf{ok}^{\mathsf{A}}_{I_{1}})$ is statistically indistinguishable from uniform (privacy amplification theorem \cite{DFRSS07, RK05, R05}). The proof provided by Damg{\aa}rd et al. \cite{DFLSS09} was extended by Unruh \cite{U10} to the quantum Universal Composable (UC) model, making use of ideal commitments. Now, a natural question arises: 

\

\centerline{\textit{Which commitment schemes can be used to render simulation-based security?}}

\

\noindent\textbf{Commitment scheme.} The work by Aaronson \cite{A02} presented a non-constructive proof that ``indicates that collision-resistant hashing might still be possible in a quantum setting'', giving confidence in the use of commitment schemes based on quantum-hard one-way functions in the $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ protocol. Hopefully, it was shown that commitment schemes can be built from any one-way function \cite{N91, HILL99, HR07}, including quantum-hard one-way functions. Although it is intuitive to plug in into $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ a commitment scheme derived from a quantum-hard one-way function, this does not necessarily render a simulation-based secure protocol. This happens because the nature of the commitment scheme can make the simulation-based proof difficult or even impossible. For a detailed discussion see \cite{GLSV21}.

Indeed, the commitment scheme must be quantum secure. Also, the simulator must have access to two intriguing properties: \textit{extractability} and \textit{equivocality}. Extractability means the simulator can extract the committed value from a malicious committer. Equivocal means the simulator can change the value of a committed value at a later time. Although it seems counter-intuitive to use a commitment scheme where we can violate both security properties (hiding and biding properties), it is fundamental to prove its security. Extractability is used by the simulator to prove security against the dishonest sender and equivocality is used by the simulator to prove security against the dishonest receiver. In the literature, there have been some proposals of the commitment schemes $COM$ with these properties based on:

\begin{itemize}
    \item Quantum-hard one-way functions \cite{BCKM21, GLSV21};
    \item Common Reference String (CRS) model \cite{U10, CF01};
    \item Bounded-quantum-storage model \cite{U11};
    \item Quantum hardness of the Learning With Errors assumption \cite{DFLSS09}.
\end{itemize}

\

\noindent\textbf{Composability.} The integration of secure OT executions in secure multiparty protocols \cite{Y86} should not lead to security breaches. Although it seems intuitive to assume that a secure OT protocol can be integrated within more complex protocols, proving this is highly non-trivial as it is not clear \textit{a priori} under which circumstances protocols can be composed \cite{MR09}. 

The first step towards composability properties is the development of simulation based-security. However, this does not necessarily imply composability (see Section~$4.2$ of \cite{MR09} for more details), as a composability framework is also required. In the literature, there have been some proposals for such a framework. In summary, Fehr and Schaffner \cite{FS09} developed a composability framework that allows sequential composition of quantum protocols in a classical environment. The works developed by Ben-Or and Mayers \cite{BM04} and Unruh \cite{U04, U10} extended the classical Universal Composability model \cite{C20} to a quantum setting (quantum-UC model), allowing concurrent composability. Maurer and Renner \cite{MR11} developed a more general composability framework that does not depend on the models of computation, communication, and adversary behaviour. More recently, Broadbent and Karvonen \cite{BK22} created an abstract model of composable security in terms of category theory. Up until now, and to the best of our knowledge, the composable security of the protocol $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ was only proven in the Fehr and Schaffner model \cite{FS09} by Damg{\aa}rd et al. \cite{DFLSS09} and in the quantum-UC by Unruh \cite{U10}.



\subsection{BBCS in the limited-quantum-storage model}

In this section, we review protocols based on the limited-quantum-storage model. The protocols developed under this model avoid the no-go theorems because they rely their security on reasonable assumptions regarding the storage capabilities of both parties. Under this model, there are mainly two research lines. One was started by Damg{\aa}rd, Fehr, Salvail and Schaffner \cite{DFSS05}, who developed the bounded-storage model. In this model, the parties can only store a limited number of qubits. The other research line was initiated by Wehner, Schaffner and Terhal \cite{WST08}, who developed the noisy-storage model. In this model the parties can store \textit{all} qubits. However, they are assumed to be unstable, i.e. they only have imperfect noisy storage of qubits that forces some decoherence. In both models, the adversaries are forced to use their quantum memories as both parties have to wait a predetermined time $(\Delta t)$ during the protocol.

\subsection{Bounded-quantum-storage model}

In the bounded-quantum-storage model or BQS model for short, we assume that, during the waiting time $\Delta t$, the adversaries are only able to store a fraction $0< \gamma < 1$ of the transmitted qubits, i.e. the adversary is only able to keep $q = n\gamma$ qubits. The parameter $\gamma$ is commonly called the storage rate.

\

\noindent\textbf{Protocol.} The protocol in the BQS model, $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$, is very similar to the BBCS protocol $\Pi^{\textbf{BBCS}}$ presented in Figure~\ref{fig:BBCS}. The difference is that both parties have to wait a predetermined time ($\Delta t$) after step 2. This protocol is presented in Figure~\ref{fig:BBCS_Bounded}.

\begin{figure}[h!]
\centering
\begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
    
    \centerline{$\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ \textbf{protocol}}
            
    \
    
    \textbf{Parameters:} $n$, security parameter; $\mathcal{F}$  two-universal family of hash functions.
    
    \textbf{Alice's input:} $(m_0, m_1)\in\{0,1\}^l$ (two messages). 
    
    \textbf{Bob's input:} $b\in\{0,1\}$ (bit choice).
    
    \
    
    \textit{BB84 phase}: \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    
    
    \
    
    \textit{Waiting time phase}:
    \begin{enumerate}
    \setcounter{enumi}{2}
        \item Both parties wait time $\Delta t$.
    \end{enumerate}
    
    \
    
    \textit{Oblivious key phase}: \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
     
    \
     
    \textit{Transfer phase}: \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    
    \
    
\textbf{Alice's output:} $\bot$.

\textbf{Bob's output:} $m_b$.
    
\end{tcolorbox}
    \caption{BBCS OT protocol in the bounded-quantum-storage model.}
    \label{fig:BBCS_Bounded}
\end{figure}

\

\noindent\textbf{Security.} We just comment on the security against dishonest Bob because the justification for the security against dishonest Alice is the same as in the original BBCS protocol, $\Pi^{\textbf{BBCS}}$ (see Section~\ref{sec:BBCS}). 

Under the BQS assumption, the waiting time ($\Delta t$) effectively prevents Bob from holding \textit{a large fraction} of qubits until Alice reveals the bases choices $\bm{\theta}^{\mathsf{A}}$ used during the \textit{BB84 phase}. This comes from the fact that a dishonest Bob is forced to measure a fraction of the qubits, leading him to lose information about Alice's bases $\bm{\theta}^{\mathsf{A}}$.

More specifically, Damg{\aa}rd et al. \cite{DFRSS07} showed that, with overwhelming probability, the loss of information about Alice's oblivious key ($\mathsf{ok}^{\mathsf{A}}_{I_{1}}$) is described by a lower bound on the min-entropy \cite{F10}

$$H_{\text{min}}(\mathsf{ok}^{\mathsf{A}}_{I_{1}} | E) \geq 
\frac{1}{4}n - \gamma n - l - 1.$$
Similarly to the $\mathcal{F}_{\textbf{COM}}-$hybrid model, the min-entropy value has to be bounded by a factor proportional to the security parameter $n$. To render a positive bound, we derive an upper bound on the fraction of qubits that can be saved in the receiver's quantum memory, while preserving the security of the protocol, i.e. $\gamma < \frac{1}{4}$. 

The above upper bound was later improved by K\"onig et al. \cite{KWW12} to $\gamma < \frac{1}{2}$. The authors also showed that the BQS model is a special case of the noisy-quantum-storage model. Subsequently, based on higher-dimensional mutually unbiased bases, Mandayam and Wehner \cite{MW11} presented a protocol that is still secure when an adversary cannot store even a small fraction of the transmitted pulses. In this latter work, the storage rate $\gamma$ approaches $1$ for increasing dimension.

\

\noindent\textbf{Composability.} The initial proofs given by Damg{\aa}rd et al. \cite{DFSS05, DFRSS07} were only developed under the stand-alone security model \cite{WW08}. In this model the composability of the protocol is not guaranteed to be secure. These proofs were extended by Wehner and Wullschleger \cite{WW08} to a simulation-based framework that guarantees sequential composition. Also, in a parallel work, Fehr and Schaffner developed a sequential composability framework under which $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ is secure considering the BQS model. 

The more desirable quantum-UC framework was extended by Unruh and combined with the BQS model \cite{U11}. In Unruh's work, he developed the concept of BQS-UC security which, as in UC security, implies a very similar composition theorem. The only difference is that in the BQS-UC framework we have to keep track of the quantum memory-bound used by the machines activated during the protocol. Under this framework, Unruh follows a different approach as he does not use the protocol $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ (Figure~\ref{fig:BBCS_Bounded}). He presents a BQS-UC secure commitment protocol and composes it with the $\Pi^{\textbf{BBCS}}_{\mathcal{F}_{\textbf{COM}}}$ protocol (Figure~\ref{fig:BBCS_COM}) in order to get a constant-round protocol that BQS-UC-emulates any two-party functionality.

\

\subsection{Noisy-quantum-storage model}

The noisy-quantum-storage model, or NQS model for short, is a generalization of the BQS model. In the NQS model, the adversaries are allowed to keep any fraction $\nu$ of the transmitted qubits (including the case $\nu=1$) but their quantum memory is assumed to be noisy \cite{KWW12}, i.e. it is impossible to store qubits for some amount of time ($\Delta t$) without undergoing decoherence. 

More formally, the decoherence process of the qubits in the noisy storage is described by a completely positive trace preserving (CPTP) map (also called channel) $\mathcal{C}: \mathcal{B}(\mathcal{H}_{\text{in}})\rightarrow \mathcal{B}(\mathcal{H}_{\text{out}})$, where $\mathcal{H}_{\text{in/out}}$ is the Hilbert space of the stored qubits before (in) and after (out) the storing period $\Delta t$ and $\mathcal{B}(\mathcal{H})$ is the set of positive semi-definite operators with unitary trace acting on an Hilbert space $\mathcal{H}$. $\mathcal{C}$ receives a quantum state $\rho\in \mathcal{H}_{\text{in}}$ at time $t$ and outputs a quantum state $\rho'\in\mathcal{H}_{\text{out}}$ at a later time $t + \Delta t$. %See Figure~\ref{fig:NQS_scheme} for a description of the possible malicious behaviour. 

With this formulation, we can easily see that the BQS model is a particular case of the NQS. In BQS, the channel is of the form $\mathcal{C} = \mathds{1}^{\otimes \nu n}$, where the storage rate $\nu$ is the fraction of transmitted qubits stored in the quantum memory. The most studied scenario is restricted to $n-$fold quantum channels, i.e. $\mathcal{C} = \mathcal{N}^{\otimes \nu n}$ \cite{S10, KWW12, WST08}, where the channel $\mathcal{N}$ is applied independently to each individual stored qubit. In this particular case, it is possible to derive specific security parameters.

%\begin{figure}
%    \centering
%    \includegraphics[scale=.1]{fig/nqs_channel.jpeg}
%    \caption{During waiting times $\Delta t$, the adversary must use his noisy quantum storage described by the CPTP map $\mathcal{C}$. Before using his quantum storage, he performs any (error-free) “encoding attack” of his choosing, which consists of a measurement or an encoding into an error-correcting code. After time $\Delta t$, he receives some additional information that he can use for decoding. Figure taken from \cite{WCSL10}.}
%    \label{fig:NQS_scheme}
%\end{figure}

\

\noindent\textbf{Protocols.} The protocol from BQS model $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ is also considered to be secure in the NQS model \cite{S10}. However, the first proposed protocol analysed in this general NQS model was developed by K\"onig et al. \cite{KWW12}. This protocol draws inspiration from the research line initiated by Cachin, Crépeau and Marcil \cite{CCM98} about classical OT in the bounded-classical-storage model \cite{DHRS04, S07}. Similar to these works \cite{CCM98, DHRS04, S07}, the protocol presented by K\"onig et al. \cite{KWW12} uses the following two important techniques in its classical post-processing phase: encoding of sets and interactive hashing. The former is defined as an injective function $\mathsf{Enc}: \{0,1\}^t \rightarrow T$, where $T$ is a set of all subsets of $[n]$ with size $n/4$. The latter is a two-party protocol between Alice and Bob with the following specifications. Bob inputs some message $W^t$ and both parties receive two messages $W^t_0$ and $W^t_1$ such that there exists some $b\in\{0,1\}$ with $W^t_b = W^t$. The index $b$ is unknown to Alice, and Bob has little control over the choice of the other message $W^t$, i.e. it is randomly chosen by the functionality. %A schematic representation of the interactive hashing functionality is given in Figure~\ref{fig:IH}.

%\begin{figure}[h!]
%    \centering
%    \includegraphics[scale=.1]{fig/Interactive_hashing.jpeg}
%    \caption{Interactive hashing functionality. Figure taken %from \cite{KWW12}.}
%    \label{fig:IH}
%\end{figure}

In this section, we only present the na\"ive protocol presented in the original paper \cite{KWW12} as it is enough to give an intuition on the protocol. Although both $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ protocols are different, we keep a similar notation for a comparison purpose. The protocol $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ (Figure~\ref{fig:BBCS_Noisy}) goes as follows. The first two phases (\textit{BB84} and \textit{Waiting time}) are the same as in $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ (Figure~\ref{fig:BBCS_Bounded}). Then, both parties generate a very similar resource to oblivious keys, named \textit{weak string erasure} (WSE). After the WSE generation, Alice also holds the totality of the key $\mathsf{ok}^{\mathsf{A}}$, while Bob holds a fourth of this key, i.e. the tuple $(I, \mathsf{ok}^{\mathsf{B}} := \mathsf{ok}^{\mathsf{A}}_I)$ where $I$ is the set of indexes they measured in the same basis and its size is given by $|I| = \frac{n}{4}$. Then, along with a method of encoding sets into binary strings, both parties use interactive hashing to generate two index subsets, $I_0$ and $I_1$. The two subsets ($I_0$ and $I_1$) together with two $2-$universal hash functions are enough for Alice to generate her output messages $(m_0, m_1)$ and for Bob to get his bit choice along with the corresponding message $(b, m_b)$. For more details on the protocols for encodings of sets and interactive hashing, we refer to Ding et al. \cite{DHRS04} and Savvides \cite{S07}.

\begin{figure}[h!]
\centering
\begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
                        
    \centerline{Na\"ive $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ \textbf{protocol}}
            
    \
    
    \textbf{Parameters:} $n$, security parameter; $\mathcal{F}$ two-universal family of hash functions.
    
    \textbf{Alice's input:} $\bot$.  
    
    \textbf{Bob's input:} $\bot$. 
    
    \
    
    \textit{BB84 phase}: \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    
    
    \
    
    \textit{Waiting time phase}: \textcolor{gray}{Same as in $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ (Figure~\ref{fig:BBCS_Bounded}).}
    
    \
    
    \textit{Weak String Erasure phase}: \textcolor{gray}{Similar to \textit{Oblivious key phase} of $\Pi^{\textbf{BBCS}}$ (Figure~\ref{fig:BBCS}).}
    \begin{enumerate}
        \setcounter{enumi}{3}
        \item Alice reveals to Bob the bases $\bm{\theta}^{\mathsf{A}}$ used during the \textit{BB84 phase} and sets her oblivious key to $\mathsf{ok}^{\mathsf{A}}:=\bm{x}^{\mathsf{A}}$.
        
        \item Bob computes $\mathsf{e}^\mathsf{B} = \bm{\theta}^{\mathsf{B}} \oplus \bm{\theta}^{\mathsf{A}}$. Then, he defines $I = \{ i : \mathsf{e}^{\mathsf{B}}_i = 0 \}$ and sets $\mathsf{ok}^{\mathsf{B}}:=\bm{x}^{\mathsf{B}}_{I}$.
        
        \item If $|I| < n/4$, Bob randomly adds elements to $I$ and pads the corresponding positions in $\mathsf{ok}^{\mathsf{B}}$ with $0$s. Otherwise, he randomly truncates $I$ to size $n/4$, and deletes the corresponding values in $\mathsf{ok}^{\mathsf{B}}$.
    \end{enumerate}
     
    \ 
     
    \textit{Interactive hashing phase}: 
    \begin{enumerate}
        \setcounter{enumi}{6}
        \item Alice and Bob execute interactive hashing with Bob’s input $W$ to be equal to a description of $I = \mathsf{Enc}(W)$. They interpret the outputs $W_0$ and $W_1$ as descriptions of subsets $I_0$ and $I_1$ of $[n]$.
    \end{enumerate}
    
    \
    
    \textit{Transfer phase}:
            \begin{enumerate}
            \setcounter{enumi}{4}
                \item Alice generates random $f_0, f_1 \leftarrow_{\$}\mathcal{F}$ and sends them to Bob.
                \item Alice computes the pair of messages $(m_0, m_1)$ as $m_i = f_i(\mathsf{ok}^{\mathsf{A}}_{I_{i}})$.
                \item Bob computes $b\in\{0, 1\}$ by comparing $I = I_b$ and computes $m_b = f_b(\mathsf{ok}^{\mathsf{B}}_{I})$. 
            \end{enumerate}
    
    
   
    
    \
    
$\mathsf{S}$ \textbf{output:} $(m_0, m_1)\in\{0,1\}^l$ (two messages).

$\mathsf{R}$ \textbf{output:} $(b, m_b)$ where $b\in\{0,1\}$ (bit choice).
    
\end{tcolorbox}
    \caption{BBCS OT protocol in the noisy-quantum-storage model.}
    \label{fig:BBCS_Noisy}
\end{figure}


\

\noindent\textbf{Security.} Based on the original BQS protocol (Figure~\ref{fig:BBCS_Bounded}), the first proofs in the NQS model were developed by Schaffner, Wehner and Terhal \cite{WST08, STW09}. However, in these initial works, the authors only considered individual-storage attacks, where the adversary treats all incoming qubits equally. Subsequently, Schaffner \cite{S10} was able to prove the security of $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ against arbitrary attacks in the more general NQS model defined by K\"onig et al. \cite{KWW12}. 

In this more general NQS model, the security of both protocols $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ (Figures~\ref{fig:BBCS_Bounded} and \ref{fig:BBCS_Noisy}) against a dishonest receiver depends on the ability to set a lower-bound on the min-entropy of the ``unknown'' key $\mathsf{ok}^{\mathsf{A}}_{I_{1-b}}$ given the receiver's quantum side information. His quantum side information is given by the output of the quantum channel $\mathcal{C}$ when applied to the received states. More formally, one has to lower-bound the expression $H_{\text{min}}\left(\mathsf{ok}^{\mathsf{A}}_{I_{1-b}} | \mathcal{C}\left(Q_{\text{in}}\right)\right)$, where $Q_{\text{in}}$ denotes the subsystem of the received states before undergoing decoherence. It is proven \cite{KWW12} that this lower-bound depends on the receiver's maximal success probability of correctly decoding a randomly chosen n-bit string $x \in \{0,1\}^n$ sent over the quantum
channel $\mathcal{C}$, i.e. $P^{\mathcal{C}}_{\text{succ}}(n)$. %This result is given by Lemma~\ref{lemma:NQS_sec_lemma}.

%\begin{lemma}[Lemma II.2. from \cite{KWW12}]

%Consider an arbitrary ccq-state $\rho_{XTQ}$, and let $\varepsilon, \varepsilon' > 0$ be arbitrary. Let $\mathcal{C} : \mathcal{B}(\mathcal{H}_{Q_{\text{in}}}) \rightarrow \mathcal{B}(\mathcal{H}_{Q_{\text{out}}})$ be an arbitrary CPTP map, where $\mathcal{H}_{Q_{\text{in}}}$ and $\mathcal{H}_{Q_{\text{out}}}$ are the Hilbert space corresponding to the subsystem $Q_{\text{in}}$ and $Q_{\text{out}}$, respectively. Then,

%$$H^{\varepsilon + \varepsilon'}_{\min}(X|T\mathcal{C}(Q)) \geq -\log P^{\mathcal{C}}_{\text{succ}}\left(\left\lfloor H^{\varepsilon}_{\min}(X|T) - \log\frac{1}{\varepsilon}\right\rfloor \right),$$ where $H^{\epsilon}$ denotes the smooth min-entropy.

%\label{lemma:NQS_sec_lemma}
%\end{lemma}

For particular channels $\mathcal{C} = \mathcal{N}^{\otimes \nu }$, K\"onig et al. \cite{KWW12} concluded that security in the NQS model can be obtained in case

$$c_{\mathcal{N}} \cdot \nu < \frac{1}{2},$$
where $c_{\mathcal{N}}$ is the classical capacity of quantum channels $\mathcal{N}$ satisfying a particular property (strong-converse property).




\subsection{Experimental attacks}

Although QKD and QOT protocols are proved to be theoretically secure, experimental implementations may come with loopholes that allow to break their security. This mismatch between theory and practice comes from the fact that theoretical proofs usually assume that the physical apparatus of honest parties cannot be hacked. However, imperfections in both the generation and measurement the qubits can be exploited in multiple ways to perform quantum attacks. We refer the interested reader to proper review articles \cite{LCT14, Pirandola2020} on QKD attacks and possible mitigation measures. Here, we briefly discuss the impact of these attacks on BBCS-based QOT protocols.

\subsubsection{QOT attacks}

It is important to stress that there is a fundamental difference between QKD and QOT protocols. In QKD, both parties can cooperate to detect an external attack, whereas, in QOT, both parties are distrustful of each other. Moreover, QKD external attacks pressupose that the adversary has physical access to the quantum channel and is able to play some sort of man-in-the-middle attack. Regarding QOT protocols, both parties are already linked by a quantum channel. Therefore, in principle, QOT attacks require less engineering effort to succeed as the adversary is already using the quantum channel.

According to the security properties of QOT, Alice must not know Bob's bit $b$ and Bob must not know $m_{1-b}$. Regarding BBCS-based QOT protocols, its security depends on the security requirements of oblivious keys. Informally, this means that Alice must not be able to know which set of indexes is known by Bob (i.e. $\mathsf{e}^\mathsf{B}$) and Bob must have limited knowledge on Alice's key (i.e. $\mathsf{ok}^\mathsf{A}$). These two pieces of information ($\mathsf{e}^\mathsf{B}$ and $\mathsf{ok}^\mathsf{A}$) can be easily deduced if the adversary has access to the quantum bases used by the other party ($\bm{\theta}^{\mathsf{A}}$ or $\bm{\theta}^{\mathsf{B}}$). Indeed, Alice gets $\mathsf{e}^\mathsf{B}$ by computing $\bm{\theta}^{\mathsf{B}} \oplus \bm{\theta}^{\mathsf{A}}$ and Bob gets $\mathsf{ok}^\mathsf{A}$ by measuring all the qubits with Alice's bases $\bm{\theta}^{\mathsf{A}}$. Therefore, the main aim of the adversary is to use his quantum channel to gain some information (or control) about the set of bases used by the other. Two of the most common attacks on quantum systems are faked-state attacks \cite{MH05} (FSA) and trojan-horses attacks \cite{GFKZR06} (THA). The former targets measurement apparatus only and the latter can target both preparation and measurement apparatus. In a prepare-and-measure setting, FSA can only be used by Alice (sender) while THA can be used by both. For the sake of exposition, let us see how these two approaches can be used to attack both $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\mathcal{F}_\textbf{COM}}$ protocols. The attacks on $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ follow the same reasoning but the notation vary slightly. 

We denote by $\tilde{\bm{\theta}}^{\mathsf{B}}_J \leftarrow \mathcal{A}_{\textbf{qok}}(J)$ Alice's quantum hacking procedure ($\mathcal{A}_{\textbf{qok}}(J)$) that breaks the security requirements of oblivious keys and provides her with Bob's bases ($\tilde{\bm{\theta}}^{\mathsf{B}}_J$) from index set $J$. Similarly for Bob, i.e. $\tilde{\bm{\theta}}^{\mathsf{A}}_J \leftarrow \mathcal{B}_{\textbf{qok}}(J)$.

\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{$\rotPi^{\mathsf{A}}_{\textbf{FSA}}$ attack}
            
            \
            
            \textbf{Alices's input:}  set of indexes $J$ of size $q$.
            
            \
 
 	\begin{enumerate}
         \item Alice performs some faked-state attack $\left\{\tilde{\theta}^{\mathsf{B}}_{j}\right\}_{j\in J} \leftarrow \mathcal{A}_{\textbf{qok}}(J) $ where $\tilde{\theta}^{\mathsf{B}}_{j}\in\{+, \times\}$ or $\tilde{\theta}^{\mathsf{B}}_{j}=\bot$. 
         \item If $\exists j\in J$ such that $\tilde{\theta}^{\mathsf{B}}_{j} \neq \bot$:
		\begin{enumerate}
            \item $b=0$ if $j\in I_b$, ;
            \item $b=1$ if $j\notin I_b$.
		\end{enumerate}
		\item Otherwise, sets $b = \bot$.
         
	\end{enumerate}            
            
            \
            
        \textbf{Alice's output:} $b$.

        
        \end{tcolorbox}
    \caption{Alice faked-state attack to $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\mathcal{F}_\textbf{COM}}$ protocols.}
    \label{fig:A_FSA}
\end{figure}

\

\noindent\textbf{FSA attacks.} These attacks can be performed with well crafted optical signals that allow Alice to take control over Bob's measurement outcomes. In summary, as described by Jain et al. \cite{JSKEML16}, when both parties' bases coincide, Bob's detector clicks; when these are orthogonal, he gets no detection event ($\bot$). In other words, Alice forces Bob to only use the measurements where their bases coincide. So, the indexes corresponding to no detection events will be discarded by both parties whereas the others will be used in the rest of the protocol. This way, Alice gains full knowledge about Bob's bases and can easily distinguish $I_0$ from $I_1$. Note that Alice does not have to attack all measurement turns. She only needs one successful FSA to guess one basis. This happens with high probability in the number of attacks $q$,
$$Pr[\text{Success Alice attack in }q\text{ rounds} ] = 1 - \bigg(\frac{1}{2}\bigg)^q.$$
From this basis, Alice can deduce to which set ($I_0$ or $I_1$) the corresponding index ($j$) belongs. As Bob computes his message $m_b$ with the set where their basis coincide, and since Alice computes both messsages $m_0$ and $m_1$ out of both sets, she can determine Bob's message $m_b$. Indeed, $m_b$ will be the message that comes from the set where $j$ belongs. The attack $\rotPi^{\mathsf{A}}_{\textbf{FSA}}$ against both $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\mathcal{F}_\textbf{COM}}$ is summarized in Figure~\ref{fig:A_FSA}.

\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{$\rotPi^{\mathsf{A}}_{\textbf{THA}}$ attack}
            
            \
            
            \textbf{Alices's input:}  one index element, $j$.
            
            \
            
            \begin{enumerate}
         \item Alice performs some trojan-horse attack $\left\{\tilde{\theta}^{\mathsf{B}}_{j}\right\} \leftarrow \mathcal{A}_{\textbf{qok}}(i) $ where $\tilde{\theta}^{\mathsf{B}}_{j}\in\{+, \times\}$.
         \item Alice compares the received basis $\tilde{\theta}^{\mathsf{B}}_{j}$ with her corresponding base $\theta^{\mathsf{A}}_{j}$. Denote by $\tilde{\mathsf{e}}^{\mathsf{B}}_j := \tilde{\theta}^{\mathsf{B}}_{j} \oplus \theta^{\mathsf{A}}_{j}$. 
         \item Upon receiving $I_b$ from R:
         \begin{enumerate}
             \item $b=\tilde{\mathsf{e}}^{\mathsf{B}}_j$ if $j\in I_b$;
             \item $b=1-\tilde{\mathsf{e}}^{\mathsf{B}}_j$ if $j\notin I_b$.
         \end{enumerate}
         
    \end{enumerate}    
            
            \
            
        \textbf{Alice's output:} $b$.

        
        \end{tcolorbox}
    \caption{Alice trojan-horse attack to $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\mathcal{F}_\textbf{COM}}$ protocols.}
    \label{fig:A_THA}
\end{figure}

\

\noindent\textbf{THA attacks.} These types of attacks are performed by sending bright pulses into the equipment under attack and scanning through the different reflections to obtain the bases used. Likewise the FSA, Alice only needs to successfully find one basis used by Bob. By comparing her basis and Bob's basis to that particular turn, she can find Bob's bit $b$. This attack $\rotPi^{\mathsf{A}}_{\textbf{THA}}$ is summarized in Figure~\ref{fig:A_THA}. 

Bob's attack through THA is more challenging. Not only he has to successfully guess \textit{all} Alices's bases, he also has to be able to correctly measure the corresponding qubits after leaking the sender's bases. Without the help of quantum memories, this procedure is much more difficult to succeed. %and allow Bob to extract the whole key, $\mathsf{ok}^{\mathsf{A}}$. 
Bob's attack $\rotPi^{\mathsf{B}}_{\textbf{THA}}$ is summarized in Figure~\ref{fig:B_THA}.





%This is more problematic if Bob undertakes passive basis choice (e.g. the basis choice is achieved by Bob's set-up randomly at the polarizing beam splitter)


%To be more specific, even if Alice is able to find only \textit{one} Bob's choice base of the $j-$th index, she can perfectly guess Bob's bit choice $b$ when she receives the index set $I_b$. The attack is described in Figure~\ref{}. On the other hand, Bob's attack is more challenging because he has to successfully guess \textit{all} Alice's basis. Besides that, Bob attack is technologically more challenging than Alice's. This is because Bob has to be able to leak Alice basis and immediately measure the corresponding qubit. Otherwise, in case he has access to quantum memory he can hold the qubits before measuring them. However, this is unfeasible with current technology. Bob's attack is summarized in Figure~\ref{A_FSA}.

\begin{figure}[h!]
    \centering
        \begin{tcolorbox}[enhanced, 
                        frame hidden,
                        ]
            
            \centerline{$\rotPi^{\mathsf{B}}_{\textbf{THA}}$ attack}
            
            \
            
            \textbf{Parameters:}  $n$, security parameter..
            
            \
            
            \begin{enumerate}
         \item Bob performs some trojan-horse attack to all qubits sent by Alice, i.e. $\left\{\tilde{\theta}^{\mathsf{A}}_{i}\right\}_{i\in [n]} \leftarrow \mathcal{B}_{\textbf{qok}}([n]) $ where $\tilde{\theta}^{\mathsf{A}}_{i}\in\{+, \times\}$.
         \item Bob measures the received states $\ket{\bm{x}^{\textsf{A}}}_{\bm{\theta}^{\textsf{A}}}$ with the correct bases, $\left\{\tilde{\theta}^{\mathsf{A}}_{i}\right\}_{i\in [n]}$. 
    \end{enumerate}    
            
            \
            
        \textbf{Bob's output:} $\mathsf{ok}^{\mathsf{A}}$.

        
        \end{tcolorbox}
    \caption{Bob trojan-horse attack to $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ and $\Pi^{\textbf{BBCS}}_{\mathcal{F}_\textbf{COM}}$ protocols.}
    \label{fig:B_THA}
\end{figure}




\subsubsection{Countermeasures}

We have seen how two well-known quantum hacking techniques can undermine the security of oblivious keys and, consequently, the security of oblivious transfer. Fortunately, there are some countermeasures that can be applied that prevent such attacks from breaking
the system's security. These countermeasures can be divided into two categories: security patches that tackle specific vulnerabilities and novel schemes that allow faulty devices. 

Regarding the two presented possible attacks, it is commonly possible to implement security patches that prevent them. FSA can be prevented by placing an additional detector (usually called watchdog) at the entrance of the receiver's measurement device. This detector monitors possible malicious radiation that blinds his detector. Also, THA can be blocked by an isolator placed at both parties entrance devices. However, as mentioned by Jain et al. \cite{JSKEML16} these two countermeasures only prevent these attacks perfectly in case the isolators and watchdogs work at all desired frequencies, which is not the case in practice. 

There is a research line focused on the study of security patches for each technological loophole \cite{JBI+16}. However, this approach pursues the difficult task of approximating the experimental implementations to the ideal protocols. It would be more desirable to develop protocols that already consider faulty devices and are robust against any kind of quantum hacking attack. This is the main goal of device-independent (DI) cryptography, where we drop the assumption that quantum devices cannot be controlled by the adversary and we treat them simply as black-boxes \cite{MY04, E91}. Here, we give a general overview of the state-of-the-art of DI protocols. For a more in-depth description, we refer to the corresponding original works.

\

\noindent\textbf{Kaniewski-Wehner DI protocol \cite{KW16}.} The first DI protocol of QOT was presented in a joint work by Kaniewski and Wehner \cite{KW16} and its security proof was improved by Ribeiro et al. \cite{RTK+18}. The protocol was proved to be secure in the noisy-quantum-storage (NQS) model as it uses the original NQS protocol $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ (Figure 4) for trusted devices. It analyzes two cases leading to slightly different protocols. 

First, they assume that the devices have the same behaviour every time they are used (memoryless assumption). This assumption allows for testing the devices independently from the actual protocol, leading to a DI protocol in two phases: device-testing phase and protocol phase . Under this memoryless assumption, one can prove that the protocol is secure against general attacks using proof techniques borrowed from \cite{KWW12}. Then, they analyse the case \textit{without} the memoryless assumption. In that case, it is useless to test the devices in advance as they can change their behaviour later. Consequently, the structure of the initial DI protocol (with two well-separated phases) has to be changed to accommodate this more realistic scenario. That is, the rounds for the device-testing phase have to be intertwined with the rounds for the protocol phase. 

As a common practice in DI protocols, the DI property comes from some violation of Bell inequalities \cite{AGM06}, which ensures a certain level of entanglement. This means that, in the protocol phase, the entanglement-based variant of $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ must be used. Here, the difference lies in the initial states prepared by Alice, which, for this case, are maximally entangled states $\ketbra{\Phi^+}$, where $\ket{\Phi^+} = \frac{1}{\sqrt{2}}(\ket{00} + \ket{11})$. The Bell inequality used in this case comes from the Clauser-Holt-Shimony-Horne (CHSH) inequality \cite{CHSH69}.


\

\noindent\textbf{Broadbent-Yuen DI protocol \cite{BY21}.} More recently, Broadbent and Yuen \cite{BY21} used the $\Pi^{\textbf{BBCS}}_{\textbf{bqs}}$ (Figure 3) to develop a DI protocol in the BQS model. Similar to Kaniewski and Wehner's work, the protocol is secure under the memoryless assumption. However, they do not require non-communication assumptions that ensure security from Bell inequality violations. Instead of using the CSHS inequality, their work uses a recent self-testing protocol \cite{MDC+21, MV21} based on a post-quantum computational assumption (hardness of Learning with Errors (LWE) problem \cite{P15}).

\

\noindent\textbf{Ribeiro-Wehner MDI protocol \cite{RW20}.} Ribeiro and Wehner \cite{RW20} developed an OT protocol in the measurement-device-independent (MDI) regime \cite{LCQ12} to avoid the technological challenges in the implementation of DI protocols \cite{MDR+19}. In this regime, two parties perform QOT with untrusted measurement devices while trusting their sources. In addition, this work was motivated by the fact that, so far, there is no security proof in the DI setting. Furthermore, many attacks on the non device-independent protocols affect the measurement devices rather than the sources \cite{SRK+15}. The presented protocol follows the research line of K\"onig et al. \cite{KWW12} and start by executing a weak string erasure in the MDI setting (MDI-WSE phase). For this reason, it is also proved to be secure in the NQS model.

The initial MDI-WSE phase goes as follows. Both Alice and Bob send random states $\ket{\bm{x}^{\mathsf{A}}}_{\bm{\theta}^{\mathsf{A}}}$ and $\ket{\bm{x}^{\mathsf{B}}}_{\bm{\theta}^{\mathsf{B}}}$, respectively, to an external agent that can be controlled by the dishonest party. The external agent performs a Bell measurement on both received states and announces the result. Bob flips his bit according to the announced result to match Alice's bits. Then, both parties follow the $\Pi^{\textbf{BBCS}}_{\textbf{nqs}}$ protocol (Figure 4) from the waiting time phase onward. A similar protocol was presented by Zhou et al. \cite{ZGG+20} which additionally takes into account error estimation to improve the security of the protocol.

%This \textit{security patches} strategy only tries to approximate the experimental implementation to the ideal protocol. However, since the ideal protocol does not assume faulty devices this task is very difficult to accomplish. A better approach to mitigate these securities issues is the development of novel schemes that allow faulty devices. This is the main aim of device-independent protocols which treat both sender and receiver devices as block boxes with minimal security guarantees. To the best of our knowledge, there are only two proposed DI protocols for oblivious keys \cite{KW16, BY21}. However, Kaniewski's protocol \cite{KW16} is just proven to be secure against sequential attacks and Broadbent's protocol \cite{BY21} uses post-quantum computational assumption. 

%To avoid the technological challenges of DI protocols, we can relax its security levels and work in the measurement-device-independent (MDI) setting. This approach allows two parties to perform QOKD with untrusted measurement devices while trusting in their sources. However, Ribeiro et al. \cite{RW20} showed that although the protocol is secure with ideal photon sources, it is not proven to be secure with imperfect sources.




%\bibliography{bibforthesis}
%\bibliographystyle{unsrt}
%\end{document}
